# Квантово стійка електронна пошта: Як ми використовуємо зашифровані поштові скриньки SQLite для захисту вашої електронної пошти {#quantum-resistant-email-how-we-use-encrypted-sqlite-mailboxes-to-keep-your-email-safe}

<img loading="lazy" src="/img/articles/quantum.webp" alt="Quantum-safe encrypted email service illustration" class="rounded-lg" />

## Зміст {#table-of-contents}

* [Передмова](#foreword)
* [Порівняння постачальників послуг електронної пошти](#email-service-provider-comparison)
* [Як це працює](#how-does-it-work)
* [Технології](#technologies)
  * [Бази даних](#databases)
  * [Безпека](#security)
  * [Поштові скриньки](#mailboxes)
  * [Паралелізм](#concurrency)
  * [Резервні копії](#backups)
  * [Пошук](#search)
  * [Проєкти](#projects)
  * [Постачальники](#providers)
* [Думки](#thoughts)
  * [Принципи](#principles)
  * [Експерименти](#experiments)
  * [Відсутність альтернатив](#lack-of-alternatives)
  * [Спробуйте пересилання електронної пошти](#try-out-forward-email)

## Передмова {#foreword}

> \[!IMPORTANT]
> Наш сервіс електронної пошти [100% відкритий код](https://github.com/forwardemail) орієнтований на конфіденційність завдяки безпечним і зашифрованим поштовим скринькам SQLite.

До запуску [Підтримка IMAP](/faq#do-you-support-receiving-email-with-imap) ми використовували MongoDB для наших потреб постійного зберігання даних.

Ця технологія чудова, і ми досі використовуємо її, але для того, щоб мати шифрування в стані спокою з MongoDB, вам потрібно скористатися послугами постачальника, який пропонує MongoDB Enterprise, такого як Digital Ocean або Mongo Atlas, або заплатити за корпоративну ліцензію (і згодом працювати із затримкою відділу продажів).

Нашій команді в [Переслати електронний лист](https://forwardemail.net) потрібне було зручне для розробників, масштабоване, надійне та зашифроване рішення для зберігання поштових скриньок IMAP. Як розробники з відкритим кодом, використання технології, за яку потрібно сплатити ліцензійний збір, щоб отримати функцію шифрування в стані спокою, суперечило б [наші принципи](#principles) – тому ми експериментували, досліджували та розробляли нове рішення з нуля, щоб задовольнити ці потреби.

Замість використання спільної бази даних для зберігання ваших поштових скриньок, ми окремо зберігаємо та шифруємо ваші поштові скриньки за допомогою вашого пароля (який є лише у вас). **Наш сервіс електронної пошти настільки безпечний, що якщо ви забудете свій пароль, то втратите свою поштову скриньку** (і вам потрібно буде відновлювати її за допомогою офлайн-резервних копій або починати все спочатку).

Продовжуйте читати, оскільки нижче ми детально розглянемо [порівняння постачальників послуг електронної пошти](#email-service-provider-comparison), [як працює наш сервіс](#how-does-it-work), [наш технологічний стек](#technologies) та інші.

## Порівняння постачальників послуг електронної пошти {#email-service-provider-comparison}

Ми є єдиним постачальником послуг електронної пошти зі 100% відкритим кодом та орієнтованим на конфіденційність, який зберігає індивідуально зашифровані поштові скриньки SQLite, пропонує необмежену кількість доменів, псевдонімів та користувачів, а також підтримує вихідні протоколи SMTP, IMAP та POP3:

**На відміну від інших постачальників послуг електронної пошти, вам не потрібно платити за сховище для кожного домену чи псевдоніма з Forward Email.** Сховище розподіляється між усім вашим обліковим записом, тому, якщо у вас є кілька користувацьких доменних імен і кілька псевдонімів для кожного, то ми — ідеальне рішення для вас. Зверніть увагу, що ви все ще можете встановити обмеження сховища за потреби для кожного домену чи псевдоніма.

<a href="/blog/best-email-service" target="_blank" class="btn btn-lg bg-success text-white btn-block btn-success">Читати порівняння сервісів електронної пошти <i class="fa fa-search-plus"></i></a>

## Як це працює {#how-does-it-work}

1. Використовуючи свій поштовий клієнт, такий як Apple Mail, Thunderbird, Gmail або Outlook, ви підключаєтеся до наших захищених серверів [IMAP](/faq#do-you-support-receiving-email-with-imap), використовуючи своє ім’я користувача та пароль:

* Ваше ім’я користувача – це ваш повний псевдонім у вашому домені, наприклад, `hello@example.com`.
* Ваш пароль генерується випадковим чином і відображається вам лише протягом 30 секунд, коли ви натискаєте <strong class="text-success"><i class="fa fa-key"></i> Згенерувати пароль</strong> з <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Мій обліковий запис <i class="fa fa-angle-right"></i> Домени</a> <i class="fa fa-angle-right"></i> Псевдоніми.

2. Після підключення ваш поштовий клієнт надішле [Команди протоколу IMAP](https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol) на наш IMAP-сервер для синхронізації вашої поштової скриньки. Це включає написання та зберігання чернеток електронних листів та інші дії, які ви можете виконувати (наприклад, позначку електронного листа як важливого або позначку листа як спаму/небажаної пошти).

3. Сервери обміну поштою (широко відомі як сервери "MX") отримують нову вхідну електронну пошту та зберігають її у вашій поштовій скриньці. Коли це трапляється, ваш поштовий клієнт отримує сповіщення та синхронізує вашу поштову скриньку. Наші сервери обміну поштою можуть пересилати вашу електронну пошту одному або кільком одержувачам (включно з [вебхуки](/faq#do-you-support-webhooks)), зберігати вашу електронну пошту для вас у вашому зашифрованому сховищі IMAP у нас **або і те, й інше**!

> \[!TIP]
> Цікаво дізнатися більше? Прочитайте [як налаштувати пересилання електронної пошти](/faq#how-do-i-get-started-and-set-up-email-forwarding), [як працює наша служба обміну поштою](/faq#how-does-your-email-forwarding-system-work) або перегляньте [наші гіди](/guides).

4. За лаштунками наша система безпечного зберігання електронної пошти працює двома способами, щоб ваші поштові скриньки були зашифровані та доступні лише вам:

* Коли від відправника надходить новий лист, наші сервери обміну поштою надсилають його на окрему тимчасову зашифровану поштову скриньку.

     ```mermaid
     sequenceDiagram
         autonumber
         actor Sender
         Sender->>MX: Inbound message received for your alias (e.g. you@yourdomain.com).
         MX->>SQLite: Message is stored in a temporary mailbox.
         Note over MX,SQLite: Forwards to other recipients and webhooks configured.
         MX->>Sender: Success!
     ```

* Коли ви підключаєтеся до нашого IMAP-сервера за допомогою поштового клієнта, ваш пароль шифрується в пам’яті та використовується для читання та запису до вашої поштової скриньки. Читання та запис даних з вашої поштової скриньки можливі лише за допомогою цього пароля. Пам’ятайте, що оскільки ви єдиний, хто має цей пароль, **лише ви** можете читати та записувати дані до своєї поштової скриньки, коли ви отримуєте до неї доступ. Наступного разу, коли ваш поштовий клієнт спробує запитувати пошту або синхронізувати її, ваші нові повідомлення будуть перенесені з цієї тимчасової поштової скриньки та збережені у вашому фактичному файлі поштової скриньки за допомогою наданого вами пароля. Зверніть увагу, що ця тимчасова поштова скринька згодом очищується та видаляється, тож повідомлення зберігаються лише у вашій поштовій скриньці, захищеній паролем.

* **Якщо ви підключені до IMAP (наприклад, за допомогою поштового клієнта, такого як Apple Mail або Thunderbird), нам не потрібно записувати дані на тимчасове сховище на диску. Натомість отримується та використовується ваш зашифрований пароль IMAP, що зберігається в оперативній пам’яті. У режимі реального часу, коли повідомлення намагається бути доставлене вам, ми надсилаємо запит WebSocket усім серверам IMAP, запитуючи їх, чи є у них активний сеанс для вас (це частина отримання), а потім передаємо цей зашифрований пароль, що зберігається в оперативній пам’яті – тому нам не потрібно записувати дані на тимчасову поштову скриньку, ми можемо записати дані на вашу фактичну зашифровану поштову скриньку, використовуючи ваш зашифрований пароль.**

     ```mermaid
     sequenceDiagram
         autonumber
         actor You
         You->>IMAP: You connect to IMAP server using an email client.
         IMAP->>SQLite: Transfer message from temporary mailbox to your alias' mailbox.
         Note over IMAP,SQLite: Your alias' mailbox is only available in-memory using IMAP password.
         SQLite->>IMAP: Retrieves messages as requested by email client.
         IMAP->>You: Success!
     ```

5. [Резервні копії ваших зашифрованих поштових скриньок](#backups) створюються щодня. Ви також можете будь-коли запросити нову резервну копію або завантажити останню резервну копію з розділу <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Мій обліковий запис <i class="fa fa-angle-right"></i> Домени</a> <i class="fa fa-angle-right"></i> Псевдоніми. Якщо ви вирішите перейти на інший сервіс електронної пошти, ви можете легко перенести, завантажити, експортувати та очистити свої поштові скриньки та резервні копії будь-коли.

## Технології {#technologies}

### Бази даних {#databases}

Ми дослідили інші можливі рівні зберігання бази даних, проте жоден з них не задовольнив наші вимоги так добре, як SQLite:

| База даних | Шифрування в стані спокою | Поштові скриньки [Sandboxed](https://en.wikipedia.org/wiki/Sandbox_\(computer_security\)) | Ліцензія | [Used Everywhere](https://www.sqlite.org/mostdeployed.html) |
| ------------------------------------------------------ | :-----------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------: | :---------------------------------------------------------: | :---------------------------------------------------------: |
| **[SQLite](https://www.sqlite.org/index.html)** :зірка: | :white_check_mark: Так, з [SQLite3MultipleCiphers](https://github.com/utelle/SQLite3MultipleCiphers) | :white_check_mark: | :white_check_mark: Суспільне надбання | :white_check_mark: |
| [MongoDB](https://www.mongodb.com/) | :x: ["Available in MongoDB Enterprise only"](https://www.mongodb.com/docs/manual/core/security-encryption-at-rest/) | :x: Реляційна база даних | :x: AGPL та `SSPL-1.0` | :х: |
| [rqlite](https://github.com/rqlite/rqlite) | :x: [Network only](https://github.com/rqlite/rqlite/issues/1406) | :x: Реляційна база даних | :white_check_mark: `MIT` | :х: |
| [dqlite](https://dqlite.io/) | :x: [Untested and not yet supported?](https://github.com/canonical/dqlite/issues/32) | :x: [Untested and not yet supported?](https://github.com/canonical/dqlite/issues/32) | :white_check_mark: `LGPL-3.0-only` | :х: |
| [PostgreSQL](https://www.postgresql.org/) | :white_check_mark: [Yes](https://www.postgresql.org/docs/current/encryption-options.html) | :x: Реляційна база даних | :white_check_mark: `PostgreSQL` (подібно до `BSD` або `MIT`) | :х: |
| [MariaDB](https://mariadb.com/) | :white_check_mark: [For InnoDB only](https://mariadb.com/kb/en/data-at-rest-encryption-overview/#which-storage-engines-does-mariadb-encryption-support) | :x: Реляційна база даних | :white_check_mark: `GPLv2` та `BUSL-1.1` | :х: |
| [CockroachDB](https://www.cockroachlabs.com/product/) | :x: [Enterprise-only feature](https://www.cockroachlabs.com/docs/v23.1/enterprise-licensing) | :x: Реляційна база даних | :x: `BUSL-1.1` та інші | :х: |

> Ось [допис у блозі, який порівнює кілька варіантів зберігання бази даних SQLite](https://gcore.com/learning/comparing-litestream-rqlite-dqlite/) у таблиці вище.

### Безпека {#security}

Ми завжди використовуємо [шифрування-в-резервному-пакеті](https://en.wikipedia.org/wiki/Data_at_rest) ([AES-256](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)), [шифрування під час передачі](https://en.wikipedia.org/wiki/Data_in_transit) ([TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)), [DNS через HTTPS](https://en.wikipedia.org/wiki/DNS_over_HTTPS) ("DoH") з використанням шифрування :tangerine: [Мандарин](https://tangeri.ne) та [sqleet](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/) ([ЧаЧа20-Полі1305](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/)) для поштових скриньок. Крім того, ми використовуємо двофакторну автентифікацію на основі токенів (на відміну від SMS, яка підозріла на [атаки типу «людина посередині»](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)), ротовані SSH-ключі з вимкненим root-доступом, ексклюзивний доступ до серверів через обмежені IP-адреси тощо.

У разі [напад злої покоївки](https://en.wikipedia.org/wiki/Evil_maid_attack) або недобросовісного співробітника від стороннього постачальника, **вашу поштову скриньку все одно можна буде відкрити лише за допомогою згенерованого вами пароля**. Будьте певні, ми не покладаємося на жодних сторонніх постачальників, окрім наших постачальників серверів скарг SOC Type 2, таких як Cloudflare, DataPacket, Digital Ocean та Vultr.

Наша мета — мати якомога менше [єдина точка відмови](https://en.wikipedia.org/wiki/Single_point_of_failure).

### Поштові скриньки {#mailboxes}

> **tldr;** Наші IMAP-сервери використовують окремо зашифровані бази даних SQLite для кожної з ваших поштових скриньок.

Вбудована база даних [SQLite надзвичайно популярний](https://www.sqlite.org/mostdeployed.html) – вона зараз працює на вашому телефоні та комп’ютері – [і використовується майже всіма основними технологіями](https://www.sqlite.org/famous.html).

Наприклад, на наших зашифрованих серверах є поштова скринька бази даних SQLite для `linux@example.com`, `info@example.com`, `hello@example.com` тощо – по одній для кожного як файл бази даних `.sqlite`. Ми також не іменуємо файли бази даних за допомогою адреси електронної пошти – натомість ми використовуємо BSON ObjectID та унікальні згенеровані UUID, які не розкривають, кому належить поштова скринька або яку адресу електронної пошти вона має (наприклад, `353a03f21e534321f5d6e267.sqlite`).

Кожна з цих баз даних шифрується за допомогою вашого пароля (який є лише у вас) з використанням [sqleet](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/) ([ЧаЧа20-Полі1305](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/)). Це означає, що ваші поштові скриньки зашифровані окремо, автономні, [пісочниця](https://en.wikipedia.org/wiki/Sandbox_\(computer_security\)) та портативні.

Ми доопрацювали SQLite, додавши наступний [PRAGMA](https://www.sqlite.org/pragma.html):

| `PRAGMA` | Мета |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `cipher=chacha20` | [ChaCha20-Poly1305 SQLite database encryption](https://utelle.github.io/SQLite3MultipleCiphers/docs/ciphers/cipher_chacha20/). Див. `better-sqlite3-multiple-ciphers` у розділі [Projects](#projects) для отримання додаткової інформації. |
| `key="****************"` | Це ваш розшифрований пароль, що зберігається лише в пам'яті, який передається через IMAP-з'єднання вашого поштового клієнта до нашого сервера. Нові екземпляри бази даних створюються та закриваються для кожного сеансу читання та запису (для забезпечення ізольованого середовища та ізоляції). |
| `journal_model=WAL` | Журнал попереднього запису ("[WAL](https://www.sqlite.org/wal.html)") [which boosts performance and allows concurrent read access](https://litestream.io/tips/#wal-journal-mode). |
| `busy_timeout=5000` | Запобігає помилкам блокування запису [while other writes are taking place](https://litestream.io/tips/#busy-timeout). |
| `synchronous=NORMAL` | Збільшує довговічність транзакцій [without data corruption risk](https://litestream.io/tips/#synchronous-pragma). |
| `foreign_keys=ON` | Забезпечує застосування посилань на зовнішні ключі (наприклад, зв'язок з однієї таблиці до іншої). [By default this is not turned on in SQLite](https://www.sqlite.org/foreignkeys.html), але для перевірки та цілісності даних його слід увімкнути. |
| `encoding='UTF-8'` | [Default encoding](https://www.sqlite.org/pragma.html#pragma_encoding) для використання з метою забезпечення безпеки розробників. |

> Усі інші значення за замовчуванням взяті з SQLite, як зазначено у [офіційна документація PRAGMA](https://www.sqlite.org/pragma.html#pragma_auto_vacuum).

### Паралелізм {#concurrency}

> **tldr;** Ми використовуємо `WebSocket` для одночасного читання та запису до ваших зашифрованих поштових скриньок SQLite.

#### Читає {#reads}

Ваш поштовий клієнт на вашому телефоні може розпізнати `imap.forwardemail.net` як одну з наших IP-адрес Digital Ocean, а ваш клієнт для робочого столу може розпізнати окрему IP-адресу з іншої [постачальник](#providers).

Незалежно від того, до якого IMAP-сервера підключається ваш поштовий клієнт, ми хочемо, щоб з’єднання зчитувало дані з вашої бази даних у режимі реального часу зі 100% точністю. Це робиться за допомогою WebSockets.

#### Записує {#writes}

Запис у базу даних дещо відрізняється, оскільки SQLite — це вбудована база даних, а ваша поштова скринька за замовчуванням зберігається в одному файлі.

Ми розглянули такі варіанти, як `litestream`, `rqlite` та `dqlite`, проте жоден з них не задовольнив наші вимоги.

Щоб виконувати запис з увімкненим логуванням попереднього запису ("[WAL](https://www.sqlite.org/wal.html)"), нам потрібно переконатися, що за це відповідає лише один сервер ("Основний"). [WAL](https://www.sqlite.org/wal.html) значно пришвидшує паралельність і дозволяє одному записувачу та кільком читачам.

Основний сервер працює на серверах даних із підключеними томами, що містять зашифровані поштові скриньки. З точки зору розподілу, ви можете вважати всі окремі сервери IMAP за `imap.forwardemail.net` вторинними серверами ("Додаткові").

Ми здійснюємо двосторонній зв'язок з [Вебсокети](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket):

* Первинні сервери використовують екземпляр сервера `WebSocketServer` класу [WS](https://github.com/websockets/ws).
* Вторинні сервери використовують екземпляр клієнта `WebSocket` класу [WS](https://github.com/websockets/ws), який обгорнутий [websocket-як-обіцяно](https://github.com/vitalets/websocket-as-promised) та [повторне підключення вебсокета](https://github.com/opensumi/reconnecting-websocket). Ці дві обгортки забезпечують повторне підключення `WebSocket` та можливість надсилати й отримувати дані для певних записів у базу даних.

### Резервні копії {#backups}

> **tldr;** Резервні копії ваших зашифрованих поштових скриньок створюються щодня. Ви також можете миттєво запросити нову резервну копію або завантажити останню резервну копію будь-коли з розділу <a href="/my-account/domains" target="_blank" rel="noopener noreferrer" class="alert-link">Мій обліковий запис <i class="fa fa-angle-right"></i> Домени</a> <i class="fa fa-angle-right"></i> Псевдоніми.

Для резервного копіювання ми просто щодня запускаємо команду SQLite `VACUUM INTO` під час обробки команди IMAP, яка використовує ваш зашифрований пароль з IMAP-з’єднання в пам’яті. Резервні копії зберігаються, якщо не виявлено жодної існуючої резервної копії або якщо хеш [SHA-256](https://en.wikipedia.org/wiki/SHA-2) у файлі змінився порівняно з останньою резервною копією.

Зверніть увагу, що ми використовуємо команду `VACUUM INTO`, а не вбудовану команду `backup`, оскільки якщо сторінку змінено під час виконання команди `backup`, то її потрібно почати спочатку. Команда `VACUUM INTO` зробить знімок. Дивіться ці коментарі щодо [GitHub](https://github.com/benbjohnson/litestream.io/issues/56) та [Новини хакерів](https://news.ycombinator.com/item?id=31387556) для отримання додаткової інформації.

Крім того, ми використовуємо `VACUUM INTO` на відміну від `backup`, оскільки команда `backup` залишить базу даних незашифрованою на короткий період, доки не буде викликано `rekey` (див. цей GitHub [коментар](https://github.com/m4heshd/better-sqlite3-multiple-ciphers/issues/46#issuecomment-1468018927) для отримання додаткової інформації).

Вторинний сервер через з’єднання `WebSocket` накаже первинному серверу виконати резервне копіювання, після чого первинний сервер отримає команду на це та згодом виконає такі дії:

1. Підключіться до вашої зашифрованої поштової скриньки.
2. Отримайте блокування запису.
3. Запустіть контрольну точку WAL через `wal_checkpoint(PASSIVE)`.
4. Виконайте команду SQLite `VACUUM INTO`.
5. Переконайтеся, що скопійований файл можна відкрити із зашифрованим паролем (захист/фіктивний захист).
6. Завантажте його до Cloudflare R2 для зберігання (або до вашого власного провайдера, якщо вказано).

<!--
7. Стисніть отриманий файл резервної копії за допомогою `gzip`.
8. Завантажте його на Cloudflare R2 для зберігання (або на сервер вашого власного провайдера, якщо вказано).
-->

Пам’ятайте, що ваші поштові скриньки зашифровані – і хоча ми маємо обмеження IP-адрес та інші заходи автентифікації для зв’язку WebSocket – у разі зловмисника ви можете бути впевнені, що якщо корисне навантаження WebSocket не матиме вашого пароля IMAP, воно не зможе відкрити вашу базу даних.

Наразі для кожної поштової скриньки зберігається лише одна резервна копія, але в майбутньому ми можемо запропонувати відновлення на певний момент часу ("[PITR](https://en.wikipedia.org/wiki/Point-in-time_recovery)").

### Пошук {#search}

Наші IMAP-сервери підтримують команду `SEARCH` зі складними запитами, регулярними виразами тощо.

Швидкий пошук забезпечується завдяки [FTS5](https://www.sqlite.org/fts5.html) та [sqlite-регулярний вираз](https://github.com/asg017/sqlite-regex#sqlite-regex).

Ми зберігаємо значення `Date` у поштових скриньках SQLite як рядки [ISO 8601](https://en.wikipedia.org/wiki/ISO\_8601) через [Date.prototype.toISOString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString) (з часовим поясом UTC для правильної роботи порівнянь рівності).

Індекси також зберігаються для всіх властивостей, що містяться в пошукових запитах.

### Проєкти {#projects}

Ось таблиця, в якій перелічено проекти, які ми використовуємо у нашому вихідному коді та процесі розробки (відсортовано в алфавітному порядку):

| Демонструвати | Мета |
| --------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [Ansible](https://www.ansible.com/) | Платформа автоматизації DevOps для легкого обслуговування, масштабування та управління всім нашим парком серверів. |
| [Bree](https://github.com/breejs/bree) | Планувальник завдань для Node.js та JavaScript з підтримкою cron, dates, ms, later та зручною для користувача підтримкою. |
| [Cabin](https://github.com/cabinjs/cabin) | Зручна для розробників бібліотека логування JavaScript та Node.js з урахуванням безпеки та конфіденційності. |
| [Lad](https://github.com/ladjs/lad) | Фреймворк Node.js, який забезпечує всю нашу архітектуру та інженерний дизайн за допомогою MVC та інших інструментів. |
| [MongoDB](https://www.mongodb.com/) | NoSQL-рішення для баз даних, яке ми використовуємо для зберігання всіх інших даних поза поштовими скриньками (наприклад, вашого облікового запису, налаштувань, доменів та конфігурацій псевдонімів). |
| [Mongoose](https://github.com/Automattic/mongoose) | Моделювання об'єктних документів MongoDB ("ODM"), яке ми використовуємо по всьому нашому стеку. Ми написали спеціальні помічники, які дозволяють нам просто продовжувати використовувати **Mongoose з SQLite** :tada: |
| [Node.js](https://nodejs.org/en) | Node.js — це кросплатформне середовище виконання JavaScript з відкритим кодом, яке запускає всі наші серверні процеси. |
| [Nodemailer](https://github.com/nodemailer/nodemailer) | Пакет Node.js для надсилання електронних листів, створення зв'язків тощо. Ми є офіційним спонсором цього проєкту. |
| [Redis](https://redis.io/) | База даних в оперативній пам'яті для кешування, каналів публікації/підписки та запитів DNS через HTTPS. |
| [SQLite3MultipleCiphers](https://github.com/utelle/SQLite3MultipleCiphers) | Розширення шифрування для SQLite, що дозволяє шифрувати всі файли бази даних (включно з журналом попередньої запису ("[WAL](https://www.sqlite.org/wal.html)"), журналом відкату тощо). |
| [SQLiteStudio](https://github.com/pawelsalawa/sqlitestudio) | Візуальний редактор SQLite (який ви також можете використовувати) для тестування, завантаження та перегляду поштових скриньок розробників. |
| [SQLite](https://www.sqlite.org/about.html) | Вбудований рівень бази даних для масштабованого, автономного, швидкого та стійкого сховища IMAP. |
| [Spam Scanner](https://github.com/spamscanner/spamscanner) | Інструмент Node.js для захисту від спаму, фільтрації електронної пошти та запобігання фішингу (наша альтернатива [Spam Assassin](https://spamassassin.apache.org/) та [rspamd](https://github.com/rspamd/rspamd)). |
| [Tangerine](https://tangeri.ne) | Запити DNS через HTTPS за допомогою Node.js та кешування за допомогою Redis – що забезпечує глобальну узгодженість та багато іншого. |
| [Thunderbird](https://www.thunderbird.net/) | Наша команда розробників використовує це (і також рекомендує це) як **бажаний поштовий клієнт для використання з Forward Email**. |
| [UTM](https://github.com/utmapp/UTM) | Наша команда розробників використовує ці віртуальні машини для iOS та macOS, щоб паралельно тестувати різні поштові клієнти з нашими серверами IMAP та SMTP. |
| [Ubuntu](https://ubuntu.com/download/server) | Сучасна серверна операційна система з відкритим кодом на базі Linux, яка забезпечує роботу всієї нашої інфраструктури. |
| [WildDuck](https://github.com/nodemailer/wildduck) | Бібліотека сервера IMAP – див. примітки до [attachment de-duplication](https://github.com/nodemailer/wildduck/blob/master/docs/in-depth/attachment-deduplication.md) та [IMAP protocol support](https://github.com/nodemailer/wildduck/blob/master/docs/in-depth/protocol-support.md). |
| [better-sqlite3-multiple-ciphers](https://github.com/m4heshd/better-sqlite3-multiple-ciphers) | Швидка та проста API-бібліотека для Node.js для програмної взаємодії з SQLite3. |
| [email-templates](https://github.com/forwardemail/email-templates) | Зручний для розробників фреймворк електронної пошти для створення, попереднього перегляду та надсилання користувацьких електронних листів (наприклад, сповіщень облікового запису тощо). |
| [json-sql-enhanced](https://github.com/forwardemail/json-sql-enhanced) | Конструктор SQL-запитів з використанням синтаксису в стилі Mongo. Це економить час нашої команди розробників, оскільки ми можемо продовжувати писати в стилі Mongo для всього стеку з агностичним підходом до бази даних. **Це також допомагає уникнути атак SQL-ін'єкцій, використовуючи параметри запиту.** |
| [knex-schema-inspector](https://github.com/knex/knex-schema-inspector) | Утиліта SQL для вилучення інформації про існуючу схему бази даних. Це дозволяє нам легко перевірити, чи всі індекси, таблиці, стовпці, обмеження тощо є дійсними та відповідають `1:1` вимогам. Ми навіть написали автоматичні помічники для додавання нових стовпців та індексів, якщо до схем бази даних внесено зміни (з надзвичайно детальним сповіщенням про помилки). |
| [knex](https://github.com/knex/knex) | Конструктор SQL-запитів, який ми використовуємо лише для міграції бази даних та перевірки схеми через `knex-schema-inspector`. |
| [mandarin](https://github.com/ladjs/mandarin) | Автоматичний переклад фрази [i18n](https://en.wikipedia.org/wiki/Internationalization_and_localization) з підтримкою Markdown за допомогою [Google Cloud Translation API](https://cloud.google.com/translate/docs/reference/rest). |
| [mx-connect](https://github.com/zone-eu/mx-connect) | Пакет Node.js для встановлення та вирішення з'єднань із MX-серверами, а також обробки помилок. |
| [pm2](https://github.com/Unitech/pm2) | Менеджер виробничих процесів Node.js із вбудованим балансувальником навантаження ([fine-tuned](https://github.com/Unitech/pm2/issues/5145#issuecomment-1737764214) для підвищення продуктивності). |
| [smtp-server](https://github.com/nodemailer/smtp-server) | Бібліотека SMTP-сервера – ми використовуємо її для нашого обміну поштою ("MX") та вихідних SMTP-серверів. |
| [ImapTest](https://www.imapwiki.org/ImapTest) | Корисний інструмент для тестування IMAP-серверів на відповідність бенчмаркам та сумісності протоколу IMAP зі специфікацією RFC. Цей проект був створений командою [Dovecot](https://en.wikipedia.org/wiki/Dovecot_\(software\)) (активний сервер IMAP та POP3 з відкритим кодом з липня 2002 року). Ми ретельно протестували наш IMAP-сервер за допомогою цього інструменту. |

> Ви можете знайти інші проекти, які ми використовуємо, у [наш вихідний код на GitHub](https://github.com/forwardemail).

### Постачальники {#providers}

| Постачальник | Мета |
| ----------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| [Cloudflare](https://www.cloudflare.com/) | Постачальник DNS, перевірки справності, балансувальники навантаження та сховище резервних копій за допомогою [Cloudflare R2](https://developers.cloudflare.com/r2). |
| [Digital Ocean](https://m.do.co/c/a7fe489d1b27) | Хостинг на виділеному сервері та керовані бази даних. |
| [Vultr](https://www.vultr.com/?ref=7429848) | Хостинг виділеного сервера. |
| [DataPacket](https://www.datapacket.com) | Хостинг виділеного сервера. |

## Думки {#thoughts}

### Принципи {#principles}

Пересилання електронної пошти розроблено відповідно до таких принципів:

1. Завжди будьте зручними для розробників, орієнтованими на безпеку та конфіденційність, а також прозорими.
2. Дотримуйтесь [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller), [Юнікс](https://en.wikipedia.org/wiki/Unix_philosophy), [KISS](https://en.wikipedia.org/wiki/KISS_principle), [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself), [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it), [Дванадцять факторів](https://12factor.net/), [Бритва Оккама](https://en.wikipedia.org/wiki/Occam%27s_razor) та [внутрішнього тестування](https://en.wikipedia.org/wiki/Eating_your_own_dog_food)
3. Орієнтуйтеся на недбалих, завантажених розробників та [рамен-вигідний](http://www.paulgraham.com/ramenprofitable.html) розробників

### Експерименти {#experiments}

> **tldr;** Зрештою, використання S3-сумісного об'єктного сховища та/або віртуальних таблиць технічно неможливе з міркувань продуктивності та схильне до помилок через обмеження пам'яті.

Ми провели кілька експериментів, що призвели до нашого остаточного рішення SQLite, як обговорювалося вище.

Одним із них було спробувати використати [rclone]() та SQLite разом із S3-сумісним шаром сховища.

Цей експеримент допоміг нам краще зрозуміти та виявити граничні випадки, пов'язані з використанням rclone, SQLite та [VFS](https://en.wikipedia.org/wiki/Virtual_file_system):

* Якщо ви ввімкнете прапорець `--vfs-cache-mode writes` за допомогою rclone, то читання буде дозволено, проте запис буде кешуватися.
* Якщо у вас є кілька серверів IMAP, розподілених по всьому світу, то кеш на них буде вимкнено, якщо у вас немає одного записувача та кількох слухачів (наприклад, підхід pub/sub).
* Це неймовірно складно, і додавання будь-якої додаткової складності, подібної до цієї, призведе до появи більшої кількості точок відмови.
* Постачальники сховищ, сумісні з S3, не підтримують часткові зміни файлів, що означає, що будь-яка зміна файлу `.sqlite` призведе до повної зміни та повторного завантаження бази даних.
* Існують інші рішення, такі як `rsync`, але вони не зосереджені на підтримці журналу попереднього запису ("[WAL](https://www.sqlite.org/wal.html)"), тому ми зрештою переглянули Litestream. На щастя, наше використання шифрування вже шифрує файли [WAL](https://www.sqlite.org/wal.html) для нас, тому нам не потрібно покладатися на Litestream для цього. Однак ми ще не були впевнені в Litestream для використання у виробничому середовищі, і нижче є кілька приміток з цього приводу.
* Використання цього параметра `--vfs-cache-mode writes` (*єдиний* спосіб використання SQLite замість `rclone` для запису) призведе до спроби скопіювати всю базу даних з нуля в пам'ять – обробка однієї поштової скриньки розміром 10 ГБ є прийнятною, проте обробка кількох поштових скриньок з надзвичайно великим обсягом сховища призведе до того, що сервери IMAP зіткнуться з обмеженнями пам'яті та помилками `ENOMEM`, помилками сегментації та пошкодженням даних.
* Якщо ви спробуєте використовувати SQLite [Віртуальні столи](https://www.sqlite.org/vtab.html) (наприклад, використовуючи [s3db](https://github.com/jrhy/s3db)), щоб дані зберігалися на рівні сховища, сумісному з S3, ви зіткнетеся з кількома іншими проблемами:
* Читання та запис будуть надзвичайно повільними, оскільки кінцеві точки API S3 потрібно буде обробляти за допомогою методів HTTP `.sqlite`0, `.sqlite`1, `.sqlite`2 та `.sqlite`3.
* Тести розробки показали, що перевищення 500 тис. – 1 млн.+ записів в оптоволоконному інтернеті все ще обмежене пропускною здатністю запису та читання для S3-сумісних провайдерів. Наприклад, наші розробники виконували цикли `.sqlite`4 для виконання як послідовних SQL-інструкцій `.sqlite`5, так і для виконання великих обсягів даних. В обох випадках продуктивність була вражаюче низькою.
* Віртуальні таблиці **не можуть мати індекси**, інструкції `.sqlite`6 та `.sqlite`7 `.sqlite`8, що призводить до затримок до 1-2 хвилин або більше залежно від обсягу даних.
* Об'єкти зберігалися в незашифрованому вигляді, і вбудована підтримка шифрування відсутня. * Ми також досліджували використання `.sqlite`9, який концептуально та технічно схожий на попередній пункт (тому має ті ж проблеми). Можливим варіантом було б використання власної збірки `rsync`0, обгорнутої шифруванням, наприклад, `rsync`1 (яку ми зараз використовуємо в нашому рішенні вище) через `rsync`2.
* Іншим можливим підходом було б використання `rsync`3, проте це має обмеження 32 ГБ і вимагатиме складних проблем зі збіркою та розробкою.
* Необхідні оператори `rsync`4 (тому це повністю виключає використання віртуальних таблиць). Нам потрібні оператори `rsync`5, щоб наш перехоплювач з `rsync`6 працював належним чином, що гарантує, що дані не будуть пошкоджені, а отримані рядки можна буде перетворити на дійсні документи відповідно до наших визначень схеми `rsync`7 (яка включає обмеження, тип змінної та перевірку довільних даних).
* Майже всі S3-сумісні проекти, пов'язані з SQLite у спільноті відкритого коду, написані на Python (а не на JavaScript, який ми використовуємо для 100% нашого стеку).
* Бібліотеки стиснення, такі як `rsync`8 (див. `rsync`9), виглядають багатообіцяючими, але __PROTECTED_LINK_189__0. Натомість, стиснення на стороні програми для типів даних, таких як __PROTECTED_LINK_189__1, __PROTECTED_LINK_189__2, __PROTECTED_LINK_189__3, __PROTECTED_LINK_189__4, __PROTECTED_LINK_189__5 та __PROTECTED_LINK_189__6, буде чистішим та простішим підходом (і його також легше перенести, оскільки ми можемо зберігати прапорець або стовпець __PROTECTED_LINK_189__7 – або навіть використовувати __PROTECTED_LINK_189__8 __PROTECTED_LINK_189__9 для стиснення або __PROTECTED_LINK_190__0 для відсутності стиснення як метадані бази даних).
* На щастя, у нас вже реалізовано дедуплікацію вкладень у сховищі нашого IMAP-сервера – тому кожне повідомлення з однаковим вкладенням не зберігатиме копію вкладення – натомість зберігається одне вкладення для кількох повідомлень і потоків у поштовій скриньці (і згодом використовується зовнішнє посилання).
* Проект Litestream, який є рішенням для реплікації та резервного копіювання SQLite, є дуже перспективним, і ми, найімовірніше, використовуватимемо його в майбутньому.
* Не хочу дискредитувати автора(ів) – адже ми любимо їхню роботу та внесок у розробку програмного забезпечення з відкритим кодом вже понад десять років – проте з реального використання здається, що існують __PROTECTED_LINK_190__1 та __PROTECTED_LINK_190__2.
* Відновлення резервної копії має бути безперебійним та простим. Використання такого рішення, як MongoDB з __PROTECTED_LINK_190__3 та __PROTECTED_LINK_190__4, не тільки нудне, але й трудомістке та має складність налаштування.
* Бази даних SQLite спрощують це (це один файл).
* Ми хотіли розробити рішення, де користувачі могли б взяти свою поштову скриньку та піти в будь-який момент.
* Прості команди Node.js для __PROTECTED_LINK_190__5, і вона назавжди видаляється з дискового сховища.
* Ми можемо аналогічно використовувати S3-сумісний API з HTTP __PROTECTED_LINK_190__6 для легкого видалення знімків та резервних копій для користувачів.
* SQLite був найпростішим, найшвидшим та найекономічнішим рішенням.

### Відсутність альтернатив {#lack-of-alternatives}

Наскільки нам відомо, жодні інші поштові служби не розроблені таким чином і не мають відкритого коду.

Ми *вважаємо, що це може бути пов'язано* з тим, що існуючі поштові служби використовують застарілі технології у виробництві з [код спагетті](https://en.wikipedia.org/wiki/Spaghetti_code) :spaghetti:.

Більшість, якщо не всі, існуючі постачальники послуг електронної пошти мають або закритий вихідний код, або рекламуються як такі, що мають відкритий вихідний код, **але насправді лише їхній інтерфейс є відкритим**.

**Найчутливіша частина електронної пошти** (фактичне зберігання/взаємодія IMAP/SMTP) **виконується на сервері (бекенді), а *не* на інтерфейсі (клієнті)**.

### Спробуйте пересилання електронної пошти {#try-out-forward-email}

Зареєструйтесь сьогодні на <https://forwardemail.net>! :rocket: