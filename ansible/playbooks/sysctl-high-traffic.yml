---
# High-Traffic Server Sysctl Tuning Playbook
# Optimized for servers with long-lived connections (MongoDB, Redis, SQLite with WebSockets)
#
# Usage:
#   - name: Import high-traffic sysctl tuning
#     import_playbook: sysctl-high-traffic.yml
#     vars:
#       target_hosts: mongo  # or redis, sqlite, etc.
#       service_name: MongoDB  # Human-readable name for logging
#       sysctl_file_name: mongodb  # Will create /etc/sysctl.d/99-{service}.conf

- hosts: "{{ target_hosts }}"
  name: "Configure {{ service_name }} High-Traffic Sysctl Parameters"
  become: true
  become_user: root
  tasks:
    # Get total system memory for auto-scaling calculations
    - name: Get total system memory in KB
      shell: grep MemTotal /proc/meminfo | awk '{print $2}'
      register: total_mem_kb
      changed_when: false

    # Calculate memory-based values
    - name: Calculate auto-scaled memory values
      set_fact:
        # TCP memory limits: min, pressure, max (in pages, 4KB each)
        # Use 25%, 50%, 75% of total memory
        tcp_mem_min: "{{ (total_mem_kb.stdout | int * 0.25 / 4) | int }}"
        tcp_mem_pressure: "{{ (total_mem_kb.stdout | int * 0.50 / 4) | int }}"
        tcp_mem_max: "{{ (total_mem_kb.stdout | int * 0.75 / 4) | int }}"
        # Buffer sizes: Use 16MB max (safe kernel limit), or 5% of RAM if less
        # Conservative values to avoid "Invalid argument" errors on different kernels
        max_buffer_size: "{{ [16777216, (total_mem_kb.stdout | int * 1024 * 0.05) | int] | min }}"
        # min_free_kbytes: 1% of total RAM (minimum 64MB, maximum 512MB)
        min_free_kb: "{{ [65536, [524288, (total_mem_kb.stdout | int * 0.01) | int] | min] | max }}"

    - name: "Configure high-traffic sysctl parameters for {{ service_name }}"
      ansible.builtin.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: false
        sysctl_file: "/etc/sysctl.d/99-{{ sysctl_file_name }}.conf"
      loop:
        # Memory Management
        - { name: 'vm.swappiness', value: '1' }  # Minimize swapping, prefer RAM
        - { name: 'vm.dirty_ratio', value: '20' }  # Max % of RAM for dirty pages before blocking writes
        - { name: 'vm.dirty_background_ratio', value: '10' }  # Start background writeback at 10%
        - { name: 'vm.dirty_expire_centisecs', value: '3000' }  # Dirty data older than 30s gets written
        - { name: 'vm.dirty_writeback_centisecs', value: '500' }  # Check for dirty data every 5s
        - { name: 'vm.min_free_kbytes', value: "{{ min_free_kb }}" }  # Auto-scaled: 1% of RAM (64MB-512MB)
        
        # Network - Connection Queue Tuning
        - { name: 'net.core.somaxconn', value: '65536' }  # Max connection backlog
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '65536' }  # Max SYN backlog
        - { name: 'net.core.netdev_max_backlog', value: '65536' }  # Max packets in kernel backlog
        
        # Network - TCP Keepalive (Long-Lived Connections)
        - { name: 'net.ipv4.tcp_keepalive_time', value: '120' }  # Start keepalive after 2min idle
        - { name: 'net.ipv4.tcp_keepalive_intvl', value: '30' }  # Send keepalive every 30s
        - { name: 'net.ipv4.tcp_keepalive_probes', value: '3' }  # 3 failed probes = dead connection
        
        # Network - TCP Connection Lifecycle
        - { name: 'net.ipv4.tcp_fin_timeout', value: '30' }  # Fast cleanup of closed connections
        - { name: 'net.ipv4.tcp_tw_reuse', value: '1' }  # Reuse TIME_WAIT sockets for new connections
        - { name: 'net.ipv4.tcp_max_tw_buckets', value: '2000000' }  # Max TIME_WAIT sockets
        
        # Network - Port Range (High Connection Volume)
        - { name: 'net.ipv4.ip_local_port_range', value: '10000 65535' }  # Expand ephemeral port range
        
        # Network - TCP Buffer Tuning (Auto-scaled based on RAM)
        - { name: 'net.core.rmem_max', value: "{{ max_buffer_size }}" }  # Auto-scaled: max 16MB
        - { name: 'net.core.wmem_max', value: "{{ max_buffer_size }}" }  # Auto-scaled: max 16MB
        - { name: 'net.ipv4.tcp_rmem', value: "4096 87380 {{ max_buffer_size }}" }  # TCP read buffer (min, default, max)
        - { name: 'net.ipv4.tcp_wmem', value: "4096 65536 {{ max_buffer_size }}" }  # TCP write buffer (min, default, max)
        - { name: 'net.ipv4.tcp_mem', value: "{{ tcp_mem_min }} {{ tcp_mem_pressure }} {{ tcp_mem_max }}" }  # Auto-scaled: 25%, 50%, 75% of RAM
        
        # Network - TCP Performance
        - { name: 'net.ipv4.tcp_slow_start_after_idle', value: '0' }  # Disable slow start after idle
        - { name: 'net.ipv4.tcp_window_scaling', value: '1' }  # Enable TCP window scaling (critical for high-bandwidth)
        - { name: 'net.ipv4.tcp_timestamps', value: '1' }  # Enable TCP timestamps
        - { name: 'net.ipv4.tcp_sack', value: '1' }  # Enable selective acknowledgments
        - { name: 'net.ipv4.tcp_congestion_control', value: 'bbr' }  # Use BBR congestion control (better for WebSockets)
        
        # File System
        - { name: 'fs.file-max', value: '2097152' }  # Max open file descriptors system-wide
        - { name: 'fs.nr_open', value: '2097152' }  # Max open file descriptors per process

    # Reload sysctl after all values are written to file
    # This ensures rmem_max/wmem_max are applied before tcp_rmem/tcp_wmem
    - name: "Reload sysctl to apply {{ service_name }} settings"
      shell: sysctl -p /etc/sysctl.d/99-{{ sysctl_file_name }}.conf
      changed_when: true

    - name: Display auto-scaled memory values
      debug:
        msg: |
          Auto-scaled sysctl values based on {{ (total_mem_kb.stdout | int / 1024 / 1024) | round(2) }}GB RAM:
          - tcp_mem: {{ tcp_mem_min }} {{ tcp_mem_pressure }} {{ tcp_mem_max }} (pages)
          - rmem_max/wmem_max: {{ (max_buffer_size | int / 1024 / 1024) | round(0) }}MB (capped at 16MB)
          - min_free_kbytes: {{ (min_free_kb | int / 1024) | round(0) }}MB
