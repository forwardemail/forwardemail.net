# Copyright (c) Forward Email LLC
# SPDX-License-Identifier: BUSL-1.1

---
- name: Import security playbook
  import_playbook: security.yml
- name: Import SSH keys playbook
  import_playbook: ssh-keys.yml

- hosts: redis
  name: Prepare for certificates
  become: true
  become_user: root
  tasks:
    - name: Ensure /var/www/production directory exists for certificates
      file:
        path: /var/www/production
        state: directory
        owner: deploy
        group: deploy
        mode: "0755"

- name: Import certificates playbook
  import_playbook: certificates.yml

- hosts: redis
  name: Hostname
  become: true
  become_user: root
  tasks:
    - name: Validate required environment variables
      assert:
        that:
          - lookup('env', 'REDIS_HOST') != ''
          - lookup('env', 'REDIS_PASSWORD') != ''
          - lookup('env', 'REDIS_TLS_PORT') != ''
          - lookup('env', 'SSL_CERT_PATH') != ''
          - lookup('env', 'SSL_KEY_PATH') != ''
          - lookup('env', 'SSL_CA_PATH') != ''
          - lookup('env', 'AWS_ACCESS_KEY_ID') != ''
          - lookup('env', 'AWS_SECRET_ACCESS_KEY') != ''
          - lookup('env', 'AWS_ENDPOINT_URL') != ''
          - lookup('env', 'BACKUP_SECRET') != ''
        fail_msg: |
          Required environment variables are missing for Redis playbook.
          Please ensure the following variables are set in your .env file:
          - REDIS_HOST
          - REDIS_PASSWORD
          - REDIS_TLS_PORT
          - SSL_CERT_PATH
          - SSL_KEY_PATH
          - SSL_CA_PATH
          - AWS_ACCESS_KEY_ID
          - AWS_SECRET_ACCESS_KEY
          - AWS_ENDPOINT_URL
          - BACKUP_SECRET
        quiet: false

    - name: Set hostname
      hostname:
        name: "{{ lookup('env', 'REDIS_HOST') }}"

- hosts: redis
  name: Redis
  become: true
  become_user: root
  handlers:
    - name: Reload UFW
      ufw:
        state: reloaded
    - name: Restart Redis
      service:
        name: redis-server
        state: restarted
  tasks:
    # Redis-specific sysctl optimizations
    # Note: THP, ulimits, and base sysctl settings are inherited from security.yml
    - name: Configure Redis-specific sysctl parameters
      ansible.builtin.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-redis.conf
      loop:
        - { name: 'vm.overcommit_memory', value: '1' }
        - { name: 'net.core.somaxconn', value: '65536' }
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '65536' }

    # Configure swap for Redis stability
    # Redis official docs: "swap file size is equal to amount of memory on your system"
    # https://redis.io/docs/latest/operate/oss_and_stack/management/admin/
    - name: Get total system memory in MB
      shell: free -m | awk '/^Mem:/{print $2}'
      register: total_memory_mb
      changed_when: false

    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swapfile_stat

    - name: Check current swap size
      shell: swapon --show=SIZE --noheadings --bytes | head -1
      register: current_swap_bytes
      changed_when: false
      failed_when: false

    - name: Calculate required swap size in bytes
      set_fact:
        required_swap_mb: "{{ total_memory_mb.stdout | int }}"
        required_swap_bytes: "{{ (total_memory_mb.stdout | int) * 1024 * 1024 }}"

    - name: Disable existing swap if size doesn't match
      command: swapoff /swapfile
      when:
        - swapfile_stat.stat.exists
        - current_swap_bytes.stdout != ""
        - current_swap_bytes.stdout | int != required_swap_bytes | int
      ignore_errors: true

    - name: Remove old swap file if size doesn't match
      file:
        path: /swapfile
        state: absent
      when:
        - swapfile_stat.stat.exists
        - current_swap_bytes.stdout != ""
        - current_swap_bytes.stdout | int != required_swap_bytes | int

    - name: Create swap file with size equal to RAM
      command: fallocate -l {{ required_swap_mb }}M /swapfile
      args:
        creates: /swapfile

    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
        owner: root
        group: root

    - name: Format swap file
      command: mkswap /swapfile
      when: not swapfile_stat.stat.exists or (current_swap_bytes.stdout | int != required_swap_bytes | int)
      register: mkswap_result
      changed_when: "'Setting up swapspace' in mkswap_result.stdout"

    - name: Enable swap file
      command: swapon /swapfile
      when: mkswap_result is changed

    - name: Add swap to /etc/fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        state: present
        regexp: '^/swapfile'

    - name: Set swappiness for Redis (minimize swapping but allow it for safety)
      ansible.builtin.sysctl:
        name: vm.swappiness
        value: '1'
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-redis.conf

    # Ensure Redis SSL directory exists
    - name: Ensure Redis TLS/SSL configuration directory exists
      file:
        path: /etc/redis/ssl
        state: directory
        owner: redis
        group: redis
        mode: "0750"

    # Copy certificates from /var/www/production to Redis directory
    - name: Copy SSL certificate from /var/www/production to Redis directory
      copy:
        src: "{{ lookup('env', 'SSL_CERT_PATH') }}"
        dest: /etc/redis/ssl/redis.crt
        owner: redis
        group: redis
        mode: "0400"
        remote_src: yes

    - name: Copy SSL private key from /var/www/production to Redis directory
      copy:
        src: "{{ lookup('env', 'SSL_KEY_PATH') }}"
        dest: /etc/redis/ssl/redis.key
        owner: redis
        group: redis
        mode: "0400"
        remote_src: yes

    - name: Copy CA certificate from /var/www/production to Redis directory
      copy:
        src: "{{ lookup('env', 'SSL_CA_PATH') }}"
        dest: /etc/redis/ssl/ca.pem
        owner: redis
        group: redis
        mode: "0400"
        remote_src: yes

    # Clean up certificates from /var/www/production for security
    - name: Remove SSL certificate from /var/www/production (security cleanup)
      file:
        path: "{{ lookup('env', 'SSL_CERT_PATH') }}"
        state: absent

    - name: Remove SSL private key from /var/www/production (security cleanup)
      file:
        path: "{{ lookup('env', 'SSL_KEY_PATH') }}"
        state: absent

    - name: Remove CA certificate from /var/www/production (security cleanup)
      file:
        path: "{{ lookup('env', 'SSL_CA_PATH') }}"
        state: absent

    # Install Redis using geerlingguy.redis role
    - name: Install Redis
      include_role:
        name: geerlingguy.redis
      vars:
        redis_bind_interface: "0.0.0.0"
        redis_requirepass: "{{ lookup('env', 'REDIS_PASSWORD') }}"
        redis_port: "{{ lookup('env', 'REDIS_PORT') }}"
        redis_appendonly: "yes"
        redis_appendfsync: "everysec"
        redis_save:
          - 900 1
          - 300 10
          - 60 10000
        redis_extra_config: |
          # TLS/SSL Configuration
          tls-port {{ lookup('env', 'REDIS_TLS_PORT') }}
          port 0
          tls-cert-file /etc/redis/ssl/redis.crt
          tls-key-file /etc/redis/ssl/redis.key
          tls-ca-cert-file /etc/redis/ssl/ca.pem
          tls-auth-clients no

          # Performance Optimizations
          tcp-backlog 65536
          tcp-keepalive 0
          maxclients 10000

    # UFW Configuration
    - name: Enable ufw
      ufw:
        state: enabled
        policy: deny
        direction: incoming

    - name: Limit ufw ssh
      ufw:
        rule: limit
        port: 22
        proto: tcp

    - name: Allow ssh
      ufw:
        rule: allow
        port: 22
        proto: tcp

    # Fetch IP whitelist and configure UFW
    - name: Fetch IP whitelist from forwardemail.net
      uri:
        url: https://forwardemail.net/ips/v4.txt?comments=false
        return_content: true
      register: ip_whitelist_response

    - name: Parse IP whitelist
      set_fact:
        allowed_ips: "{{ ip_whitelist_response.content.split('\n') | select('match', '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$') | list }}"

    - name: Allow Redis TLS port from whitelisted IPs
      ufw:
        rule: allow
        from_ip: "{{ item }}"
        to_port: "{{ lookup('env', 'REDIS_TLS_PORT') }}"
        proto: tcp
        comment: "Auto-whitelist Redis TLS"
      loop: "{{ allowed_ips }}"
      notify: Reload UFW

    # Install UFW whitelist update script
    - name: Create UFW whitelist update script
      copy:
        dest: /usr/local/bin/update-redis-ufw-whitelist.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Fetch current IP list
          NEW_IPS=$(curl -s https://forwardemail.net/ips/v4.txt?comments=false | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')

          # Get current UFW rules for Redis TLS port
          REDIS_TLS_PORT="${REDIS_TLS_PORT:-6380}"
          CURRENT_IPS=$(ufw status | grep "${REDIS_TLS_PORT}/tcp" | grep "ALLOW" | awk '{print $3}' | sort -u)

          # Track if changes were made
          CHANGED=0

          # Add new IPs
          for ip in $NEW_IPS; do
            if ! echo "$CURRENT_IPS" | grep -q "^${ip}$"; then
              ufw allow from "$ip" to any port "$REDIS_TLS_PORT" proto tcp comment "Auto-whitelist Redis TLS"
              CHANGED=1
            fi
          done

          # Remove old IPs (not in new list)
          for ip in $CURRENT_IPS; do
            if ! echo "$NEW_IPS" | grep -q "^${ip}$"; then
              # Find and delete the rule
              RULE_NUM=$(ufw status numbered | grep "${REDIS_TLS_PORT}/tcp" | grep "$ip" | grep -oP '^\[\s*\K[0-9]+' | head -1)
              if [ -n "$RULE_NUM" ]; then
                echo "y" | ufw delete "$RULE_NUM"
                CHANGED=1
              fi
            fi
          done

          # Reload UFW if changes were made
          if [ $CHANGED -eq 1 ]; then
            ufw reload
          fi

    # Create systemd timer for UFW whitelist updates
    - name: Create UFW whitelist update systemd service
      copy:
        dest: /etc/systemd/system/redis-ufw-whitelist-update.service
        content: |
          [Unit]
          Description=Update Redis UFW IP Whitelist

          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/update-redis-ufw-whitelist.sh

    - name: Create UFW whitelist update systemd timer
      copy:
        dest: /etc/systemd/system/redis-ufw-whitelist-update.timer
        content: |
          [Unit]
          Description=Update Redis UFW IP Whitelist Every 10 Minutes

          [Timer]
          OnBootSec=5min
          OnUnitActiveSec=10min

          [Install]
          WantedBy=timers.target

    - name: Enable and start UFW whitelist update timer
      systemd:
        daemon_reload: true
        name: redis-ufw-whitelist-update.timer
        enabled: true
        state: started

    # Install AWS CLI and GPG dependencies
    - name: Install AWS CLI and GPG dependencies
      apt:
        name:
          - python3-pip
          - unzip
          - gnupg
        update_cache: true

    - name: Install AWS CLI
      shell: |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
          unzip -q /tmp/awscliv2.zip -d /tmp
          /tmp/aws/install
          rm -rf /tmp/aws /tmp/awscliv2.zip
        fi
      args:
        creates: /usr/local/bin/aws

    # Create Redis backup script
    - name: Create Redis backup script
      copy:
        dest: /usr/local/bin/backup-redis.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables (set via systemd service or environment)
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${REDIS_BACKUP_BUCKET:-forwardemail-backups}"
          BACKUP_SECRET="${BACKUP_SECRET}"
          REDIS_DATA_DIR="${REDIS_DATA_DIR:-/var/lib/redis}"

          # Check if BACKUP_SECRET is set
          if [ -z "$BACKUP_SECRET" ]; then
            echo "Error: BACKUP_SECRET environment variable is not set"
            exit 1
          fi

          # Timestamp and path
          TIMESTAMP=$(date +%Y/%m/%d/%H)
          BACKUP_NAME="redis-backup-$(date +%Y%m%d-%H%M%S).rdb.gpg"
          S3_PATH="s3://${BACKUP_BUCKET}/redis/${TIMESTAMP}/${BACKUP_NAME}"

          # Trigger Redis BGSAVE
          redis-cli -a "${REDIS_PASSWORD}" BGSAVE

          # Wait for BGSAVE to complete
          while [ "$(redis-cli -a "${REDIS_PASSWORD}" LASTSAVE)" == "$(redis-cli -a "${REDIS_PASSWORD}" LASTSAVE)" ]; do
            sleep 1
          done

          # Give it a moment to finish writing
          sleep 2

          # Encrypt and upload RDB file to S3
          gpg --symmetric --cipher-algo AES256 --batch --yes --passphrase "$BACKUP_SECRET" < "${REDIS_DATA_DIR}/dump.rdb" | \
            aws s3 cp - "${S3_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"

          echo "Redis encrypted backup completed: ${S3_PATH}"

    # Create Redis backup cleanup script
    - name: Create Redis backup cleanup script
      copy:
        dest: /usr/local/bin/cleanup-redis-backups.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${REDIS_BACKUP_BUCKET:-forwardemail-backups}"

          # Calculate dates
          THIRTY_DAYS_AGO=$(date -d "30 days ago" +%s)
          SEVEN_DAYS_AGO=$(date -d "7 days ago" +%s)

          # List all backups
          aws s3 ls "s3://${BACKUP_BUCKET}/redis/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | while read -r line; do
            FILE_DATE=$(echo "$line" | awk '{print $1}')
            FILE_PATH=$(echo "$line" | awk '{print $4}')
            FILE_TIMESTAMP=$(date -d "$FILE_DATE" +%s)

            # Delete backups older than 30 days
            if [ "$FILE_TIMESTAMP" -lt "$THIRTY_DAYS_AGO" ]; then
              aws s3 rm "s3://${BACKUP_BUCKET}/${FILE_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"
              echo "Deleted old backup: ${FILE_PATH}"
            # For backups 8-30 days old, keep only one per day (delete others)
            elif [ "$FILE_TIMESTAMP" -lt "$SEVEN_DAYS_AGO" ]; then
              # Extract date from path (YYYY/MM/DD)
              BACKUP_DATE=$(echo "$FILE_PATH" | grep -oP 'redis/\K[0-9]{4}/[0-9]{2}/[0-9]{2}')

              # Get all backups for this date
              DAILY_BACKUPS=$(aws s3 ls "s3://${BACKUP_BUCKET}/redis/${BACKUP_DATE}/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | awk '{print $4}' | sort)

              # Keep only the latest backup for the day
              LATEST_BACKUP=$(echo "$DAILY_BACKUPS" | tail -1)

              # Delete all except the latest
              for backup in $DAILY_BACKUPS; do
                if [ "$backup" != "$LATEST_BACKUP" ]; then
                  aws s3 rm "s3://${BACKUP_BUCKET}/${backup}" --endpoint-url="${AWS_ENDPOINT_URL}"
                  echo "Deleted non-latest daily backup: ${backup}"
                fi
              done
            fi
          done

          echo "Redis backup cleanup completed"

    # Create systemd service for Redis backup
    - name: Create Redis backup systemd service
      copy:
        dest: /etc/systemd/system/redis-backup.service
        content: |
          [Unit]
          Description=Redis Backup to Cloudflare R2

          [Service]
          Type=oneshot
          Environment="AWS_ACCESS_KEY_ID={{ lookup('env', 'AWS_ACCESS_KEY_ID') }}"
          Environment="AWS_SECRET_ACCESS_KEY={{ lookup('env', 'AWS_SECRET_ACCESS_KEY') }}"
          Environment="AWS_ENDPOINT_URL={{ lookup('env', 'AWS_ENDPOINT_URL') }}"
          Environment="REDIS_BACKUP_BUCKET={{ lookup('env', 'REDIS_BACKUP_BUCKET') | default('forwardemail-backups', true) }}"
          Environment="BACKUP_SECRET={{ lookup('env', 'BACKUP_SECRET') }}"
          Environment="REDIS_PASSWORD={{ lookup('env', 'REDIS_PASSWORD') }}"
          Environment="REDIS_DATA_DIR={{ lookup('env', 'REDIS_DATA_DIR') | default('/var/lib/redis', true) }}"
          ExecStart=/usr/local/bin/backup-redis.sh
          ExecStartPost=/usr/local/bin/cleanup-redis-backups.sh

    # Create systemd timer for Redis backup (every 6 hours)
    - name: Create Redis backup systemd timer
      copy:
        dest: /etc/systemd/system/redis-backup.timer
        content: |
          [Unit]
          Description=Redis Backup Every 6 Hours

          [Timer]
          OnBootSec=15min
          OnUnitActiveSec=6h

          [Install]
          WantedBy=timers.target

    - name: Enable and start Redis backup timer
      systemd:
        daemon_reload: true
        name: redis-backup.timer
        enabled: true
        state: started