# Copyright (c) Forward Email LLC
# SPDX-License-Identifier: BUSL-1.1

---
- name: Import security playbook
  import_playbook: security.yml
- name: Import SSH keys playbook
  import_playbook: ssh-keys.yml

- hosts: redis
  name: Hostname
  become: true
  become_user: root
  tasks:
    - name: Set hostname
      hostname:
        name: "{{ lookup('env', 'REDIS_HOST') }}"

- hosts: redis
  name: Redis
  become: true
  become_user: root
  handlers:
    - name: Reload UFW
      ufw:
        state: reloaded
    - name: Restart Redis
      service:
        name: redis-server
        state: restarted
  tasks:
    # Install Redis using geerlingguy.redis role
    - name: Install Redis
      include_role:
        name: geerlingguy.redis
      vars:
        redis_bind_interface: "0.0.0.0"
        redis_requirepass: "{{ lookup('env', 'REDIS_PASSWORD') }}"
        redis_port: 6379
        redis_appendonly: "yes"
        redis_appendfsync: "everysec"
        redis_save:
          - 900 1
          - 300 10
          - 60 10000
        redis_extra_config: |
          # TLS/SSL Configuration
          tls-port 6380
          port 0
          tls-cert-file {{ lookup('env', 'SSL_CERT_PATH') }}
          tls-key-file {{ lookup('env', 'SSL_KEY_PATH') }}
          tls-ca-cert-file {{ lookup('env', 'SSL_CA_PATH') }}
          tls-auth-clients no

    # UFW Configuration
    - name: Enable ufw
      ufw:
        state: enabled
        policy: deny
        direction: incoming

    - name: Limit ufw ssh
      ufw:
        rule: limit
        port: 22
        proto: tcp

    - name: Allow ssh
      ufw:
        rule: allow
        port: 22
        proto: tcp

    # Fetch IP whitelist and configure UFW
    - name: Fetch IP whitelist from forwardemail.net
      uri:
        url: https://forwardemail.net/ips/v4.txt?comments=false
        return_content: true
      register: ip_whitelist_response

    - name: Parse IP whitelist
      set_fact:
        allowed_ips: "{{ ip_whitelist_response.content.split('\n') | select('match', '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$') | list }}"

    - name: Allow Redis TLS port from whitelisted IPs
      ufw:
        rule: allow
        from_ip: "{{ item }}"
        to_port: 6380
        proto: tcp
        comment: "Auto-whitelist Redis TLS"
      loop: "{{ allowed_ips }}"
      notify: Reload UFW

    # Install UFW whitelist update script
    - name: Create UFW whitelist update script
      copy:
        dest: /usr/local/bin/update-redis-ufw-whitelist.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Fetch current IP list
          NEW_IPS=$(curl -s https://forwardemail.net/ips/v4.txt?comments=false | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')

          # Get current UFW rules for Redis TLS port
          CURRENT_IPS=$(ufw status | grep "6380/tcp" | grep "ALLOW" | awk '{print $3}' | sort -u)

          # Track if changes were made
          CHANGED=0

          # Add new IPs
          for ip in $NEW_IPS; do
            if ! echo "$CURRENT_IPS" | grep -q "^${ip}$"; then
              ufw allow from "$ip" to any port 6380 proto tcp comment "Auto-whitelist Redis TLS"
              CHANGED=1
            fi
          done

          # Remove old IPs (not in new list)
          for ip in $CURRENT_IPS; do
            if ! echo "$NEW_IPS" | grep -q "^${ip}$"; then
              # Find and delete the rule
              RULE_NUM=$(ufw status numbered | grep "6380/tcp" | grep "$ip" | grep -oP '^\[\s*\K[0-9]+' | head -1)
              if [ -n "$RULE_NUM" ]; then
                echo "y" | ufw delete "$RULE_NUM"
                CHANGED=1
              fi
            fi
          done

          # Reload UFW if changes were made
          if [ $CHANGED -eq 1 ]; then
            ufw reload
          fi

    # Create systemd timer for UFW whitelist updates
    - name: Create UFW whitelist update systemd service
      copy:
        dest: /etc/systemd/system/redis-ufw-whitelist-update.service
        content: |
          [Unit]
          Description=Update Redis UFW IP Whitelist

          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/update-redis-ufw-whitelist.sh

    - name: Create UFW whitelist update systemd timer
      copy:
        dest: /etc/systemd/system/redis-ufw-whitelist-update.timer
        content: |
          [Unit]
          Description=Update Redis UFW IP Whitelist Every 10 Minutes

          [Timer]
          OnBootSec=5min
          OnUnitActiveSec=10min

          [Install]
          WantedBy=timers.target

    - name: Enable and start UFW whitelist update timer
      systemd:
        daemon_reload: true
        name: redis-ufw-whitelist-update.timer
        enabled: true
        state: started

    # Install AWS CLI and GPG dependencies
    - name: Install AWS CLI and GPG dependencies
      apt:
        name:
          - python3-pip
          - unzip
          - gnupg
        update_cache: true

    - name: Install AWS CLI
      shell: |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
          unzip -q /tmp/awscliv2.zip -d /tmp
          /tmp/aws/install
          rm -rf /tmp/aws /tmp/awscliv2.zip
        fi
      args:
        creates: /usr/local/bin/aws

    # Create Redis backup script
    - name: Create Redis backup script
      copy:
        dest: /usr/local/bin/backup-redis.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables (set via systemd service or environment)
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${REDIS_BACKUP_BUCKET:-forwardemail-backups}"
          BACKUP_SECRET="${BACKUP_SECRET}"
          REDIS_DATA_DIR="${REDIS_DATA_DIR:-/var/lib/redis}"

          # Check if BACKUP_SECRET is set
          if [ -z "$BACKUP_SECRET" ]; then
            echo "Error: BACKUP_SECRET environment variable is not set"
            exit 1
          fi

          # Timestamp and path
          TIMESTAMP=$(date +%Y/%m/%d/%H)
          BACKUP_NAME="redis-backup-$(date +%Y%m%d-%H%M%S).rdb.gpg"
          S3_PATH="s3://${BACKUP_BUCKET}/redis/${TIMESTAMP}/${BACKUP_NAME}"

          # Trigger Redis BGSAVE
          redis-cli -a "${REDIS_PASSWORD}" BGSAVE

          # Wait for BGSAVE to complete
          while [ "$(redis-cli -a "${REDIS_PASSWORD}" LASTSAVE)" == "$(redis-cli -a "${REDIS_PASSWORD}" LASTSAVE)" ]; do
            sleep 1
          done

          # Give it a moment to finish writing
          sleep 2

          # Encrypt and upload RDB file to S3
          gpg --symmetric --cipher-algo AES256 --batch --yes --passphrase "$BACKUP_SECRET" < "${REDIS_DATA_DIR}/dump.rdb" | \
            aws s3 cp - "${S3_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"

          echo "Redis encrypted backup completed: ${S3_PATH}"

    # Create Redis backup cleanup script
    - name: Create Redis backup cleanup script
      copy:
        dest: /usr/local/bin/cleanup-redis-backups.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${REDIS_BACKUP_BUCKET:-forwardemail-backups}"

          # Calculate dates
          THIRTY_DAYS_AGO=$(date -d "30 days ago" +%s)
          SEVEN_DAYS_AGO=$(date -d "7 days ago" +%s)

          # List all backups
          aws s3 ls "s3://${BACKUP_BUCKET}/redis/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | while read -r line; do
            FILE_DATE=$(echo "$line" | awk '{print $1}')
            FILE_PATH=$(echo "$line" | awk '{print $4}')
            FILE_TIMESTAMP=$(date -d "$FILE_DATE" +%s)

            # Delete backups older than 30 days
            if [ "$FILE_TIMESTAMP" -lt "$THIRTY_DAYS_AGO" ]; then
              aws s3 rm "s3://${BACKUP_BUCKET}/${FILE_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"
              echo "Deleted old backup: ${FILE_PATH}"
            # For backups 8-30 days old, keep only one per day (delete others)
            elif [ "$FILE_TIMESTAMP" -lt "$SEVEN_DAYS_AGO" ]; then
              # Extract date from path (YYYY/MM/DD)
              BACKUP_DATE=$(echo "$FILE_PATH" | grep -oP 'redis/\K[0-9]{4}/[0-9]{2}/[0-9]{2}')

              # Get all backups for this date
              DAILY_BACKUPS=$(aws s3 ls "s3://${BACKUP_BUCKET}/redis/${BACKUP_DATE}/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | awk '{print $4}' | sort)

              # Keep only the latest backup for the day
              LATEST_BACKUP=$(echo "$DAILY_BACKUPS" | tail -1)

              # Delete all except the latest
              for backup in $DAILY_BACKUPS; do
                if [ "$backup" != "$LATEST_BACKUP" ]; then
                  aws s3 rm "s3://${BACKUP_BUCKET}/${backup}" --endpoint-url="${AWS_ENDPOINT_URL}"
                  echo "Deleted non-latest daily backup: ${backup}"
                fi
              done
            fi
          done

          echo "Redis backup cleanup completed"

    # Create systemd service for Redis backup
    - name: Create Redis backup systemd service
      copy:
        dest: /etc/systemd/system/redis-backup.service
        content: |
          [Unit]
          Description=Redis Backup to Cloudflare R2

          [Service]
          Type=oneshot
          Environment="AWS_ACCESS_KEY_ID={{ lookup('env', 'AWS_ACCESS_KEY_ID') }}"
          Environment="AWS_SECRET_ACCESS_KEY={{ lookup('env', 'AWS_SECRET_ACCESS_KEY') }}"
          Environment="AWS_ENDPOINT_URL={{ lookup('env', 'AWS_ENDPOINT_URL') }}"
          Environment="REDIS_BACKUP_BUCKET={{ lookup('env', 'REDIS_BACKUP_BUCKET') | default('forwardemail-backups', true) }}"
          Environment="BACKUP_SECRET={{ lookup('env', 'BACKUP_SECRET') }}"
          Environment="REDIS_PASSWORD={{ lookup('env', 'REDIS_PASSWORD') }}"
          Environment="REDIS_DATA_DIR={{ lookup('env', 'REDIS_DATA_DIR') | default('/var/lib/redis', true) }}"
          ExecStart=/usr/local/bin/backup-redis.sh
          ExecStartPost=/usr/local/bin/cleanup-redis-backups.sh

    # Create systemd timer for Redis backup (every 6 hours)
    - name: Create Redis backup systemd timer
      copy:
        dest: /etc/systemd/system/redis-backup.timer
        content: |
          [Unit]
          Description=Redis Backup Every 6 Hours

          [Timer]
          OnBootSec=15min
          OnUnitActiveSec=6h

          [Install]
          WantedBy=timers.target

    - name: Enable and start Redis backup timer
      systemd:
        daemon_reload: true
        name: redis-backup.timer
        enabled: true
        state: started
