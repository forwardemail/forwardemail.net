# Copyright (c) Forward Email LLC
# SPDX-License-Identifier: BUSL-1.1

---
- name: Import security playbook
  import_playbook: security.yml
- name: Import SSH keys playbook
  import_playbook: ssh-keys.yml
- name: Import UFW allowlist playbook for MongoDB
  import_playbook: ufw-allowlist.yml
  vars:
    target_hosts: logs
    service_name: MongoDB
    service_port_var: LOGS_PORT
    service_port_default: "27017"
    service_identifier: logs
    ufw_comment: "Auto-whitelist Logs MongoDB"

- name: Import high-traffic sysctl tuning for MongoDB
  import_playbook: sysctl-high-traffic.yml
  vars:
    target_hosts: logs
    service_name: MongoDB
    sysctl_file_name: mongodb

- name: Import I/O and filesystem tuning for MongoDB
  import_playbook: io-filesystem-tuning.yml
  vars:
    target_hosts: logs
    service_name: MongoDB
    service_identifier: logs
    data_directory: /var/lib/mongodb
    read_ahead_kb: 16


- hosts: logs
  name: Certificate Paths
  vars_prompt:
    - name: input_key
      prompt: "Enter path to certificate private key file on local machine (e.g. /path/to/.ssl-key) [REQUIRED]"
      private: false
    - name: input_cert
      prompt: "Enter path to certificate full chain/certificate file on local machine (e.g. /path/to/.ssl-cert) [REQUIRED]"
      private: false
    - name: input_ca
      prompt: "Enter path to certificate CA bundle file on local machine (e.g. /path/to/.ssl-ca) [REQUIRED]"
      private: false
  tasks:
    - name: Fail if key path is empty
      fail:
        msg: "Certificate private key path is required. Please re-run the playbook and provide a valid path."
      when: (input_key is not defined) or (input_key | length == 0)

    - name: Fail if cert path is empty
      fail:
        msg: "Certificate file path is required. Please re-run the playbook and provide a valid path."
      when: (input_cert is not defined) or (input_cert | length == 0)

    - name: Fail if CA path is empty
      fail:
        msg: "CA bundle file path is required. Please re-run the playbook and provide a valid path."
      when: (input_ca is not defined) or (input_ca | length == 0)

    - name: Check if key file exists locally
      local_action: stat path={{ input_key }}
      become: false
      register: local_key_file

    - name: Fail when local key file does not exist
      fail:
        msg: "key file does not exist: {{ input_key }}"
      when: not local_key_file.stat.exists

    - name: Check if cert file exists locally
      local_action: stat path={{ input_cert }}
      become: false
      register: local_cert_file

    - name: Fail when local cert file does not exist
      fail:
        msg: "cert file does not exist: {{ input_cert }}"
      when: not local_cert_file.stat.exists

    - name: Check if CA file exists locally
      local_action: stat path={{ input_ca }}
      become: false
      register: local_ca_file

    - name: Fail when local CA file does not exist
      fail:
        msg: "CA file does not exist: {{ input_ca }}"
      when: not local_ca_file.stat.exists

    - name: Store certificate paths as facts
      set_fact:
        ssl_key_path: "{{ input_key }}"
        ssl_cert_path: "{{ input_cert }}"
        ssl_ca_path: "{{ input_ca }}"

- hosts: logs
  name: Hostname
  become: true
  become_user: root
  tasks:
    - name: Validate required environment variables
      assert:
        that:
          - lookup('env', 'LOGS_HOST') != ''
          - lookup('env', 'LOGS_NAME') != ''
          - lookup('env', 'LOGS_PASS') != ''
          - lookup('env', 'LOGS_PORT') != ''
          - lookup('env', 'LOGS_USER') != ''
          - lookup('env', 'AWS_ACCESS_KEY_ID') != ''
          - lookup('env', 'AWS_SECRET_ACCESS_KEY') != ''
          - lookup('env', 'AWS_ENDPOINT_URL') != ''
          - lookup('env', 'BACKUP_SECRET') != ''
        fail_msg: |
          Required environment variables are missing for MongoDB playbook.
          Please ensure the following variables are set in your .env file:
          - LOGS_HOST
          - LOGS_NAME
          - LOGS_PASS
          - LOGS_PORT
          - LOGS_USER
          - SSL_CERT_PATH
          - SSL_KEY_PATH
          - SSL_CA_PATH
          - AWS_ACCESS_KEY_ID
          - AWS_SECRET_ACCESS_KEY
          - AWS_ENDPOINT_URL
          - BACKUP_SECRET
        quiet: false

    - name: Set hostname
      hostname:
        name: "{{ lookup('env', 'LOGS_HOST') }}"

- hosts: logs
  name: MongoDB
  become: true
  become_user: root
  handlers:
    - name: Reload UFW
      ufw:
        state: reloaded
    # NOTE: MongoDB restart removed - must be done manually
    # See post-deployment instructions for manual restart procedure
  tasks:
    # MongoDB-specific sysctl optimizations
    # Note: Common high-traffic settings imported from sysctl-high-traffic.yml
    # These are MongoDB-specific additions
    - name: Configure MongoDB-specific sysctl parameters
      ansible.builtin.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-mongodb-specific.conf
      loop:
        - { name: 'vm.max_map_count', value: '262144' }  # Required for MongoDB WiredTiger storage engine

    # Configure swap for MongoDB stability
    # MongoDB requires swap to prevent OOM crashes during high memory usage
    # Best practice: swap file size = total system RAM
    - name: Get total system memory in MB
      shell: free -m | awk '/^Mem:/{print $2}'
      register: total_memory_mb
      changed_when: false

    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swapfile_stat

    - name: Check current swap size
      shell: swapon --show=SIZE --noheadings --bytes | head -1
      register: current_swap_bytes
      changed_when: false
      failed_when: false

    - name: Calculate required swap size in bytes
      set_fact:
        required_swap_mb: "{{ total_memory_mb.stdout | int }}"
        required_swap_bytes: "{{ (total_memory_mb.stdout | int) * 1024 * 1024 }}"

    - name: Check if swap resize is needed
      set_fact:
        swap_resize_needed: "{{ swapfile_stat.stat.exists and current_swap_bytes.stdout != '' and (current_swap_bytes.stdout | int != required_swap_bytes | int) }}"

    - name: Display swap resize warning
      debug:
        msg: |
          WARNING: Swap file size ({{ current_swap_bytes.stdout | int / 1024 / 1024 }}MB) does not match required size ({{ required_swap_mb }}MB).
          Swap resizing requires manual intervention to avoid system instability.
          To resize swap safely:
          1. Schedule maintenance window
          2. Stop MongoDB: systemctl stop mongod
          3. Disable swap: swapoff /swapfile
          4. Remove old swap: rm /swapfile
          5. Re-run this playbook
          Skipping automatic swap resize for safety.
      when: swap_resize_needed | bool

    - name: Skip swap operations if resize is needed
      set_fact:
        skip_swap_setup: "{{ swap_resize_needed | bool }}"

    - name: Create swap file with size equal to RAM
      command: fallocate -l {{ required_swap_mb }}M /swapfile
      args:
        creates: /swapfile
      when: not (skip_swap_setup | default(false) | bool)

    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
        owner: root
        group: root

    - name: Format swap file
      command: mkswap /swapfile
      when:
        - not (skip_swap_setup | default(false) | bool)
        - not swapfile_stat.stat.exists
      register: mkswap_result
      changed_when: "mkswap_result is not skipped and 'Setting up swapspace' in mkswap_result.stdout"

    - name: Enable swap file
      command: swapon /swapfile
      when: mkswap_result is changed

    - name: Add swap to /etc/fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        state: present
        regexp: '^/swapfile'

    - name: Set swappiness for MongoDB (minimize swapping but allow it for safety)
      ansible.builtin.sysctl:
        name: vm.swappiness
        value: '1'
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-mongodb.conf

    # Install MongoDB using custom installation (no Galaxy role)
    # WARNING: DO NOT upgrade to MongoDB 7.0 or 8.0 due to severe performance regressions
    # MongoDB 7.0 has been reported to be up to 25x slower than 6.0 for index-based queries
    # MongoDB 8.0's "36% faster" claim is compared to 7.0, NOT 6.0
    # Root causes: Slot-Based Execution engine issues and WiredTiger ticket reduction
    # Forward Email's query patterns (aggregations, index lookups, regex) are directly affected
    # References:
    # - https://www.mongodb.com/community/forums/t/performance-drop-after-upgrade-6-0-10-7-0-1/246712
    # - https://revisit.tech/blog/mongodb-8-0-performanace-is-36-percent-higher-but-there-is-a-catch/
    # - https://dev.to/manoj_from_revisit_dot_tech/mongodb-80-performance-is-36-higher-nope-its-not--35jk

    - name: Remove old MongoDB GPG keys
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /usr/share/keyrings/mongodb-server-6.0.gpg
        - /etc/apt/trusted.gpg.d/mongodb-server-6.0.gpg

    - name: Add MongoDB GPG key
      apt_key:
        url: https://www.mongodb.org/static/pgp/server-6.0.asc
        state: present
      register: gpg_key_added

    - name: Remove old MongoDB repository file
      file:
        path: /etc/apt/sources.list.d/mongodb-org-6.0.list
        state: absent

    - name: Add MongoDB repository
      apt_repository:
        repo: "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu {{ ansible_distribution_release }}/mongodb-org/6.0 multiverse"
        state: present
        filename: mongodb-org-6.0
        update_cache: yes
      register: repo_added

    - name: Update apt cache after repository changes
      apt:
        update_cache: yes
      when: gpg_key_added.changed or repo_added.changed

    - name: Unhold MongoDB packages before upgrade
      dpkg_selections:
        name: "{{ item }}"
        selection: install
      loop:
        - mongodb-org
        - mongodb-org-database
        - mongodb-org-server
        - mongodb-org-mongos
        - mongodb-org-tools
      failed_when: false

    - name: Install MongoDB 6.0.27
      apt:
        name:
          - mongodb-org=6.0.27
          - mongodb-org-database=6.0.27
          - mongodb-org-server=6.0.27
          - mongodb-org-mongos=6.0.27
          - mongodb-org-tools=6.0.27
          - mongodb-database-tools
          - numactl
        state: present
        update_cache: yes
      register: mongodb_install_result

    - name: Hold MongoDB packages after installation
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop:
        - mongodb-org
        - mongodb-org-database
        - mongodb-org-server
        - mongodb-org-mongos
        - mongodb-org-tools

    # ========================================
    # PACKAGE STATE VERIFICATION AND REPAIR
    # ========================================

    - name: Check if mongod binary exists
      stat:
        path: /usr/bin/mongod
      register: mongod_binary

    - name: Check MongoDB package installation state
      shell: dpkg -l | grep mongodb-org
      register: mongodb_packages_check
      changed_when: false
      failed_when: false

    - name: Display package state
      debug:
        msg: |
          mongod binary exists: {{ mongod_binary.stat.exists }}
          MongoDB package state:
          {{ mongodb_packages_check.stdout_lines }}

    # AGGRESSIVE REPAIR - Only if mongod binary is missing
    - name: Detect broken/half-installed packages (when binary missing)
      shell: dpkg -l | grep mongodb-org | grep -E '^(hi|iU|iF)'
      register: broken_packages
      changed_when: false
      failed_when: false
      when: not mongod_binary.stat.exists

    - name: Remove broken MongoDB packages completely
      shell: |
        dpkg --remove --force-remove-reinstreq mongodb-org mongodb-org-database mongodb-org-server mongodb-org-mongos mongodb-org-tools 2>/dev/null || true
        apt-get remove --purge -y mongodb-org* 2>/dev/null || true
        dpkg --configure -a
        apt-get install -f -y
      when:
        - not mongod_binary.stat.exists
        - broken_packages.rc == 0

    - name: Clean apt cache after removal
      apt:
        autoclean: yes
        autoremove: yes
      when:
        - not mongod_binary.stat.exists
        - broken_packages.rc == 0

    - name: Reinstall MongoDB packages from scratch
      apt:
        name:
          - mongodb-org=6.0.27
          - mongodb-org-database=6.0.27
          - mongodb-org-server=6.0.27
          - mongodb-org-mongos=6.0.27
          - mongodb-org-tools=6.0.27
          - mongodb-database-tools
          - numactl
        state: present
        update_cache: yes
      when:
        - not mongod_binary.stat.exists
        - broken_packages.rc == 0

    - name: Verify mongod binary exists after repair
      stat:
        path: /usr/bin/mongod
      register: mongod_binary_after_repair
      when: not mongod_binary.stat.exists

    - name: Fail if mongod binary is still missing after repair
      fail:
        msg: |
          MongoDB binary /usr/bin/mongod is STILL missing after aggressive repair!
          This indicates a serious package or repository issue.
          Package states: {{ mongodb_packages_check.stdout_lines }}
          Please check:
          1. MongoDB repository is accessible
          2. No disk space issues
          3. No AppArmor/SELinux blocking installation
      when:
        - not mongod_binary.stat.exists
        - broken_packages.rc == 0
        - not mongod_binary_after_repair.stat.exists

    - name: Display successful installation
      debug:
        msg: "MongoDB packages successfully installed and verified (mongod binary exists)"

    # ========================================
    # MONGOSH INSTALLATION (TARBALL METHOD)
    # ========================================
    # mongodb-mongosh package doesn't exist in MongoDB 6.0 repository
    # Install mongosh separately from tarball

    - name: Check if mongosh is already installed
      stat:
        path: /usr/local/bin/mongosh
      register: mongosh_binary

    - name: Download mongosh tarball
      get_url:
        url: https://downloads.mongodb.com/compass/mongosh-2.5.10-linux-x64.tgz
        dest: /tmp/mongosh.tgz
        mode: '0644'
      when: not mongosh_binary.stat.exists

    - name: Extract mongosh tarball
      unarchive:
        src: /tmp/mongosh.tgz
        dest: /tmp/
        remote_src: yes
      when: not mongosh_binary.stat.exists

    - name: Install mongosh binary
      copy:
        src: /tmp/mongosh-2.5.10-linux-x64/bin/mongosh
        dest: /usr/local/bin/mongosh
        mode: '0755'
        remote_src: yes
      when: not mongosh_binary.stat.exists

    - name: Install mongosh crypto library
      copy:
        src: /tmp/mongosh-2.5.10-linux-x64/bin/mongosh_crypt_v1.so
        dest: /usr/local/lib/mongosh_crypt_v1.so
        mode: '0644'
        remote_src: yes
      when: not mongosh_binary.stat.exists

    - name: Clean up mongosh installation files
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/mongosh.tgz
        - /tmp/mongosh-2.5.10-linux-x64
      when: not mongosh_binary.stat.exists

    - name: Verify mongosh installation
      command: /usr/local/bin/mongosh --version
      register: mongosh_version
      changed_when: false

    - name: Display mongosh version
      debug:
        msg: "mongosh successfully installed: {{ mongosh_version.stdout }}"

    # Disable mongosh telemetry for all users
    - name: Disable mongosh telemetry for root user
      file:
        path: /root/.mongodb/mongosh
        state: directory
        mode: '0755'

    - name: Create mongosh config for root to disable telemetry
      copy:
        dest: /root/.mongodb/mongosh/config
        content: |
          enableTelemetry: false
        mode: '0644'

    - name: Disable mongosh telemetry for deploy user
      file:
        path: /home/deploy/.mongodb/mongosh
        state: directory
        owner: deploy
        group: deploy
        mode: '0755'

    - name: Create mongosh config for deploy to disable telemetry
      copy:
        dest: /home/deploy/.mongodb/mongosh/config
        content: |
          enableTelemetry: false
        owner: deploy
        group: deploy
        mode: '0644'

    - name: Disable mongosh telemetry for devops user
      file:
        path: /home/devops/.mongodb/mongosh
        state: directory
        owner: devops
        group: devops
        mode: '0755'

    - name: Create mongosh config for devops to disable telemetry
      copy:
        dest: /home/devops/.mongodb/mongosh/config
        content: |
          enableTelemetry: false
        owner: devops
        group: devops
        mode: '0644'

    - name: Hold MongoDB packages to prevent accidental upgrades
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop:
        - mongodb-org
        - mongodb-org-database
        - mongodb-org-server
        - mongodb-org-mongos
        - mongodb-org-tools
        - mongodb-database-tools

    # Fix corrupted mongodb-database-tools package if needed
    - name: Check mongodb-database-tools package integrity
      shell: dpkg --verify mongodb-database-tools 2>&1
      register: db_tools_verify
      changed_when: false
      failed_when: false

    - name: Reinstall mongodb-database-tools if corrupted
      apt:
        name: mongodb-database-tools
        state: present
        force: yes
      when: db_tools_verify.rc != 0

    - name: Verify mongorestore is available
      command: which mongorestore
      register: mongorestore_check
      changed_when: false
      failed_when: false

    - name: Display mongorestore status
      debug:
        msg: "mongorestore is {{ 'available' if mongorestore_check.rc == 0 else 'NOT available' }} at {{ mongorestore_check.stdout if mongorestore_check.rc == 0 else 'not found' }}"

    # ========================================
    # NUMA DETECTION AND CONFIGURATION
    # ========================================

    - name: Check if NUMA is supported
      shell: numactl --hardware 2>/dev/null | grep -q "available:" && echo "supported" || echo "not_supported"
      register: numa_check
      changed_when: false
      failed_when: false

    - name: Set NUMA support fact
      set_fact:
        numa_supported: "{{ numa_check.stdout == 'supported' }}"

    - name: Set numactl prefix for MongoDB
      set_fact:
        numactl_prefix: "{{ 'numactl --interleave=all' if numa_supported else '' }}"

    - name: Display NUMA status
      debug:
        msg: "NUMA is {{ 'supported - will use numactl' if numa_supported else 'not supported - skipping numactl' }}"

    - name: Stop numad daemon (conflicts with numactl)
      systemd:
        name: numad
        state: stopped
      failed_when: false
      when: numa_supported

    - name: Disable numad daemon (conflicts with numactl)
      systemd:
        name: numad
        enabled: no
      failed_when: false
      when: numa_supported

    - name: Configure NUMA-related sysctl settings
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        sysctl_file: /etc/sysctl.d/99-mongodb-numa.conf
        reload: yes
      loop:
        - { name: 'vm.zone_reclaim_mode', value: '0' }
        - { name: 'kernel.numa_balancing', value: '0' }
      when: numa_supported

    - name: Ensure mongodb group exists
      group:
        name: mongodb
        system: yes
        state: present

    - name: Ensure mongodb user exists
      user:
        name: mongodb
        group: mongodb
        system: yes
        shell: /usr/sbin/nologin
        home: /var/lib/mongodb
        createhome: no
        state: present

    - name: Ensure MongoDB data directory exists
      file:
        path: /var/lib/mongodb
        state: directory
        owner: mongodb
        group: mongodb
        mode: '0755'

    - name: Ensure MongoDB log directory exists
      file:
        path: /var/log/mongodb
        state: directory
        owner: mongodb
        group: mongodb
        mode: '0755'

    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes

    - name: Check if mongod service file exists
      stat:
        path: /lib/systemd/system/mongod.service
      register: mongod_service_file

    - name: Create mongod service file if missing (after complete purge)
      copy:
        dest: /lib/systemd/system/mongod.service
        content: |
          [Unit]
          Description=MongoDB Database Server
          Documentation=https://docs.mongodb.org/manual
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=forking
          User=mongodb
          Group=mongodb
          RuntimeDirectory=mongodb
          PIDFile=/var/run/mongodb/mongod.pid
          ExecStart={{ numactl_prefix }} /usr/bin/mongod --config /etc/mongod.conf
          ExecStartPre=/usr/bin/mkdir -p /var/run/mongodb
          ExecStartPre=/usr/bin/chown mongodb:mongodb /var/run/mongodb
          ExecStartPre=/usr/bin/chmod 0755 /var/run/mongodb
          # Disable Transparent Huge Pages (THP) - causes performance issues
          ExecStartPre=/bin/sh -c 'echo never > /sys/kernel/mm/transparent_hugepage/enabled || true'
          ExecStartPre=/bin/sh -c 'echo never > /sys/kernel/mm/transparent_hugepage/defrag || true'
          PermissionsStartOnly=true
          LimitFSIZE=infinity
          LimitCPU=infinity
          LimitAS=infinity
          LimitNOFILE=64000
          LimitNPROC=64000
          LimitMEMLOCK=infinity
          TasksMax=infinity
          TasksAccounting=false
          Restart=always
          RestartSec=10

          [Install]
          WantedBy=multi-user.target
        owner: root
        group: root
        mode: '0644'
      when: not mongod_service_file.stat.exists

    - name: Reload systemd after creating service file
      systemd:
        daemon_reload: yes
      when: not mongod_service_file.stat.exists

    - name: Enable mongod service (will be started after configuration)
      systemd:
        name: mongod
        enabled: yes

    # Add failure notification to mongod service
    - name: Create mongod service override directory
      file:
        path: /etc/systemd/system/mongod.service.d
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: Add OnFailure notification to mongod service
      copy:
        dest: /etc/systemd/system/mongod.service.d/failure-notification.conf
        content: |
          # WARNING: This file is managed by Ansible
          # Manual changes will be overwritten on next deployment
          [Unit]
          OnFailure=failure-notification@%n.service
        owner: root
        group: root
        mode: '0644'

    - name: Reload systemd daemon for mongod override
      systemd:
        daemon_reload: yes

    # ========================================
    # STATE DETECTION - Check current MongoDB state
    # ========================================

    - name: Check if mongod is currently running
      shell: systemctl is-active mongod
      register: mongod_running
      changed_when: false
      failed_when: false

    - name: Check if admin user already exists
      shell: |
        # Try without TLS first (for base config), then with TLS (for existing secure config)
        # This ensures accurate user detection regardless of current MongoDB configuration
        /usr/local/bin/mongosh --quiet --eval "try { var u = db.getUser('{{ lookup('env', 'LOGS_USER') }}'); print(u !== null ? '1' : '0'); } catch(e) { print('0'); }" admin 2>/dev/null || \
        /usr/local/bin/mongosh --quiet --tls --tlsAllowInvalidCertificates --eval "try { var u = db.getUser('{{ lookup('env', 'LOGS_USER') }}'); print(u !== null ? '1' : '0'); } catch(e) { print('0'); }" admin 2>/dev/null || \
        echo "0"
      register: admin_user_check
      changed_when: false
      failed_when: false

    - name: Set state facts
      set_fact:
        mongod_was_running: "{{ mongod_running.stdout == 'active' }}"
        admin_user_exists: "{{ (admin_user_check.stdout | trim | int) > 0 }}"

    - name: Display current MongoDB state
      debug:
        msg: |
          MongoDB State Detection:
          - mongod running: {{ mongod_was_running }}
          - admin user exists: {{ admin_user_exists }}

    # ========================================
    # WIREDTIGER CACHE CALCULATION
    # ========================================

    - name: Calculate WiredTiger cache size (65% of RAM - 1GB)
      set_fact:
        wiredtiger_cache_gb: "{{ [(((total_mem_kb.stdout | int / 1024 / 1024) - 1) * 0.65) | round(1), 0.25] | max }}"

    - name: Display calculated WiredTiger cache size
      debug:
        msg: |
          System RAM: {{ (total_mem_kb.stdout | int / 1024 / 1024) | round(2) }}GB
          WiredTiger Cache: {{ wiredtiger_cache_gb }}GB (65% of RAM - 1GB)

    # ========================================
    # BASE CONFIGURATION (NO TLS, NO AUTH)
    # ========================================

    - name: Create base mongod.conf (without TLS/auth for initial setup)
      copy:
        dest: /etc/mongod.conf
        content: |
          # MongoDB configuration file
          # This file is managed by Ansible - manual changes may be overwritten
          # Last updated: {{ ansible_date_time.iso8601 }}

          # Where and how to store data
          storage:
            dbPath: /var/lib/mongodb
            engine: wiredTiger
            wiredTiger:
              engineConfig:
                # Cache size: 65% of (RAM - 1GB) = {{ wiredtiger_cache_gb }}GB
                cacheSizeGB: {{ wiredtiger_cache_gb }}
                journalCompressor: snappy
                directoryForIndexes: false
              collectionConfig:
                blockCompressor: snappy
              indexConfig:
                prefixCompression: true
            journal:
              enabled: true
              commitIntervalMs: 300

          # Where to write logging data
          systemLog:
            destination: file
            logAppend: true
            path: /var/log/mongodb/mongod.log
            logRotate: reopen
            verbosity: 0
            component:
              accessControl:
                verbosity: 0
              command:
                verbosity: 0

          # Network interfaces
          net:
            port: {{ lookup('env', 'LOGS_PORT') | default('27017', true) }}
            bindIp: ::,0.0.0.0
            maxIncomingConnections: 65536

          # Process management
          processManagement:
            timeZoneInfo: /usr/share/zoneinfo
            fork: true
            pidFilePath: /var/run/mongodb/mongod.pid

          # Operation Profiling (log slow operations)
          operationProfiling:
            mode: slowOp
            slowOpThresholdMs: 500
        owner: root
        group: root
        mode: '0644'

    # Restart MongoDB with base config if it was already running and user doesn't exist
    # This ensures MongoDB is in "open" mode (no TLS, no auth) for user creation
    - name: Restart mongod with base config for user creation (if needed)
      systemd:
        name: mongod
        state: restarted
      when:
        - mongod_was_running
        - not admin_user_exists

    - name: Wait for mongod to be ready with base config
      wait_for:
        port: "{{ lookup('env', 'LOGS_PORT') | default('27017', true) }}"
        delay: 3
        timeout: 60
      when:
        - mongod_was_running
        - not admin_user_exists

    # Configure MongoDB for TLS/SSL
    - name: Ensure MongoDB TLS/SSL configuration directory exists
      file:
        path: /etc/mongodb/ssl
        state: directory
        owner: mongodb
        group: mongodb
        mode: "0750"

    # Copy SSL certificates directly from local machine to MongoDB directory
    - name: Copy SSL certificate to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_cert_path'] }}"
        dest: /etc/mongodb/ssl/mongodb.crt
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Copy SSL private key to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_key_path'] }}"
        dest: /etc/mongodb/ssl/mongodb.key
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Copy CA certificate to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_ca_path'] }}"
        dest: /etc/mongodb/ssl/ca.pem
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Create MongoDB TLS/SSL certificate PEM file (cert + key)
      shell: |
        cat /etc/mongodb/ssl/mongodb.crt /etc/mongodb/ssl/mongodb.key > /etc/mongodb/ssl/mongodb.pem
        chown mongodb:mongodb /etc/mongodb/ssl/mongodb.pem
        chmod 0400 /etc/mongodb/ssl/mongodb.pem
      args:
        creates: /etc/mongodb/ssl/mongodb.pem

    # ========================================
    # USER CREATION (if needed)
    # ========================================

    - name: Start mongod temporarily for user creation (if not running and user doesn't exist)
      systemd:
        name: mongod
        state: started
      when:
        - not mongod_was_running
        - not admin_user_exists

    - name: Wait for mongod to be ready
      wait_for:
        port: "{{ lookup('env', 'LOGS_PORT') | default('27017', true) }}"
        delay: 3
        timeout: 60
      when:
        - not mongod_was_running
        - not admin_user_exists

    # DEBUG: Check environment variables before user creation
    - name: DEBUG - Verify LOGS_USER, LOGS_HOST, and LOGS_PASS are set
      debug:
        msg: |
          LOGS_USER: '{{ lookup('env', 'LOGS_USER') }}' (length: {{ lookup('env', 'LOGS_USER') | length }})
          LOGS_PASS: '{{ lookup('env', 'LOGS_PASS') }}' (length: {{ lookup('env', 'LOGS_PASS') | length }})
          LOGS_HOST: '{{ lookup('env', 'LOGS_HOST') }}' (length: {{ lookup('env', 'LOGS_HOST') | length }})
          LOGS_PASS first 8 chars: {{ lookup('env', 'LOGS_PASS')[:8] }}...
      when: not admin_user_exists

    - name: Copy MongoDB user creation Python script
      copy:
        src: files/create_logs_user.py
        dest: /tmp/create_logs_user.py
        mode: '0700'
      when: not admin_user_exists

    - name: Create MongoDB user creation script using Python
      shell: |
        export LOGS_USER='{{ lookup('env', 'LOGS_USER') }}'
        export LOGS_PASS='{{ lookup('env', 'LOGS_PASS') }}'
        python3 /tmp/create_logs_user.py
      register: script_creation
      when: not admin_user_exists
      failed_when: false

    - name: DEBUG - Show Python script output
      debug:
        msg: |
          Python script exit code: {{ script_creation.rc }}
          Python script stdout: {{ script_creation.stdout }}
          Python script stderr: {{ script_creation.stderr }}
      when: not admin_user_exists

    - name: Check Python script result
      fail:
        msg: "Failed to create MongoDB user creation script: {{ script_creation.stderr }}"
      when:
        - not admin_user_exists
        - script_creation.rc != 0

    - name: Create MongoDB admin user
      shell: |
        # Try without TLS first (for base config), then with TLS if that fails
        /usr/local/bin/mongosh --quiet admin --file /tmp/create_logs_user.js 2>/dev/null || \
        /usr/local/bin/mongosh --quiet --tls --tlsAllowInvalidCertificates admin --file /tmp/create_logs_user.js
      register: create_user_result
      when: not admin_user_exists
      failed_when: false

    - name: DEBUG - Show user creation output
      debug:
        msg: |
          User creation exit code: {{ create_user_result.rc }}
          User creation stdout: {{ create_user_result.stdout }}
          User creation stderr: {{ create_user_result.stderr }}
      when: not admin_user_exists

    - name: Remove temporary MongoDB scripts
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/create_logs_user.py
        - /tmp/create_logs_user.js
      when: not admin_user_exists
      no_log: true

    - name: Check MongoDB user creation result
      fail:
        msg: "Failed to create MongoDB admin user: {{ create_user_result.stdout | default('') }} {{ create_user_result.stderr | default('') }}"
      when:
        - not admin_user_exists
        - create_user_result.rc != 0
        - "'User already exists' not in create_user_result.stdout"
        - "'User created successfully' not in create_user_result.stdout"
        - "'User already exists' not in create_user_result.stderr"
        - "'already exists' not in create_user_result.stderr"
        - "'duplicate key' not in create_user_result.stderr"

    - name: Stop mongod if it was started temporarily
      systemd:
        name: mongod
        state: stopped
      when:
        - not mongod_was_running
        - not admin_user_exists

    # ========================================
    # FINAL CONFIGURATION (WITH TLS AND AUTH)
    # ========================================

    - name: Create final mongod.conf with TLS and authentication
      copy:
        dest: /etc/mongod.conf
        content: |
          # MongoDB configuration file
          # This file is managed by Ansible - manual changes may be overwritten
          # Last updated: {{ ansible_date_time.iso8601 }}

          # Where and how to store data
          storage:
            dbPath: /var/lib/mongodb
            engine: wiredTiger
            wiredTiger:
              engineConfig:
                # Cache size: 65% of (RAM - 1GB) = {{ wiredtiger_cache_gb }}GB
                cacheSizeGB: {{ wiredtiger_cache_gb }}
                journalCompressor: snappy
                directoryForIndexes: false
              collectionConfig:
                blockCompressor: snappy
              indexConfig:
                prefixCompression: true
            journal:
              enabled: true
              commitIntervalMs: 300

          # Where to write logging data
          systemLog:
            destination: file
            logAppend: true
            path: /var/log/mongodb/mongod.log
            logRotate: reopen
            verbosity: 0
            component:
              accessControl:
                verbosity: 0
              command:
                verbosity: 0

          # Network interfaces
          net:
            port: {{ lookup('env', 'LOGS_PORT') | default('27017', true) }}
            bindIp: ::,0.0.0.0
            maxIncomingConnections: 65536
            tls:
              mode: requireTLS
              certificateKeyFile: /etc/mongodb/ssl/mongodb.pem
              CAFile: /etc/mongodb/ssl/ca.pem
              allowConnectionsWithoutCertificates: true

          # Process management
          processManagement:
            timeZoneInfo: /usr/share/zoneinfo
            fork: true
            pidFilePath: /var/run/mongodb/mongod.pid

          # Operation Profiling (log slow operations)
          operationProfiling:
            mode: slowOp
            slowOpThresholdMs: 500

          # Security
          security:
            authorization: enabled
        owner: root
        group: root
        mode: '0644'

    # ========================================
    # RESTART MONGODB WITH SECURE CONFIGURATION
    # ========================================

    - name: Restart mongod to apply TLS and authentication
      systemd:
        name: mongod
        state: restarted
      when: admin_user_exists or (not admin_user_exists and create_user_result.rc == 0)

    - name: Wait for mongod to be ready after restart
      wait_for:
        port: "{{ lookup('env', 'LOGS_PORT') | default('27017', true) }}"
        delay: 3
        timeout: 60

    - name: Verify MongoDB authentication is enabled
      shell: |
        # Try to run a command without authentication - should fail
        if /usr/local/bin/mongosh --quiet --tls --tlsCAFile /etc/mongodb/ssl/ca.pem --host localhost:{{ lookup('env', 'LOGS_PORT') | default('27017', true) }} --eval "db.adminCommand('listDatabases')" admin 2>&1 | grep -q "Authentication failed"; then
          echo "Authentication is properly enabled"
          exit 0
        else
          echo "WARNING: MongoDB may not have authentication enabled"
          exit 1
        fi
      register: auth_check
      changed_when: false
      failed_when: false

    - name: Display authentication status
      debug:
        msg: |
          MongoDB Authentication Status:
          {{ auth_check.stdout }}

    # Configure logrotate for MongoDB logs
    - name: Create logrotate configuration for MongoDB
      copy:
        dest: /etc/logrotate.d/mongodb
        mode: '0644'
        content: |
          /var/log/mongodb/*.log {
              daily
              rotate 30
              compress
              delaycompress
              missingok
              notifempty
              create 0600 mongodb mongodb
              sharedscripts
              postrotate
                  /bin/kill -SIGUSR1 $(cat /var/run/mongodb/mongod.pid 2>/dev/null) 2>/dev/null || true
              endscript
          }

    # Disable mongosh telemetry globally
    - name: Create mongosh config directory
      file:
        path: /home/{{ item }}/.mongodb/mongosh
        state: directory
        owner: "{{ item }}"
        group: "{{ item }}"
        mode: '0755'
      loop:
        - root
        - deploy
        - devops
      ignore_errors: true

    - name: Disable mongosh telemetry for all users
      copy:
        dest: /home/{{ item }}/.mongodb/mongosh/config
        content: |
          {
            "enableTelemetry": false,
            "disableGreetingMessage": true
          }
        owner: "{{ item }}"
        group: "{{ item }}"
        mode: '0644'
      loop:
        - root
        - deploy
        - devops
      ignore_errors: true

    # UFW Configuration - Using reusable playbook
    # See ufw-allowlist.yml for implementation details

    # Install AWS CLI and GPG dependencies
    - name: Install AWS CLI and GPG dependencies
      apt:
        name:
          - python3-pip
          - unzip
          - gnupg
        update_cache: true

    - name: Install AWS CLI
      shell: |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
          unzip -q /tmp/awscliv2.zip -d /tmp
          /tmp/aws/install
          rm -rf /tmp/aws /tmp/awscliv2.zip
        fi
      args:
        creates: /usr/local/bin/aws

    # Create MongoDB backup script
    - name: Create MongoDB backup script
      copy:
        dest: /usr/local/bin/backup-mongodb.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e
          exec 2>&1  # Redirect stderr to stdout for journal logging

          echo "Starting MongoDB backup at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Environment variables (set via systemd service or environment)
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION:-auto}"
          BACKUP_BUCKET="${LOGS_BACKUP_BUCKET:-forwardemail-backups}"
          BACKUP_SECRET="${BACKUP_SECRET}"
          LOGS_PORT="${LOGS_PORT:-27017}"
          LOGS_USER="${LOGS_USER:-admin}"
          LOGS_NAME="${LOGS_NAME}"
          LOGS_HOST="${LOGS_HOST}"
          LOGS_PASS="${LOGS_PASS}"

          # Check if BACKUP_SECRET is set
          if [ -z "$BACKUP_SECRET" ]; then
            ERROR_MSG="BACKUP_SECRET environment variable is not set"
            echo "ERROR: $ERROR_MSG"
            /usr/local/bin/send-rate-limited-email.sh "mongodb-backup" "[ERROR] MongoDB Backup Failed on $(hostname)" "$ERROR_MSG"
            exit 1
          fi

          # Timestamp and path (flat structure - no folder nesting)
          BACKUP_NAME="logs-mongo-backup-$(date -u +%Y-%m-%dT%H:%M:%SZ).gz.gpg"
          S3_PATH="s3://${BACKUP_BUCKET}/mongo/${BACKUP_NAME}"

          echo "Backup destination: ${S3_PATH}"

          # Check if bucket exists, create if not
          echo "Checking if S3 bucket exists: ${BACKUP_BUCKET}"
          if ! aws s3 ls "s3://${BACKUP_BUCKET}" --endpoint-url="${AWS_ENDPOINT_URL}" >/dev/null 2>&1; then
            echo "Bucket does not exist, creating: ${BACKUP_BUCKET}"
            if ! aws s3 mb "s3://${BACKUP_BUCKET}" --endpoint-url="${AWS_ENDPOINT_URL}" 2>&1; then
              ERROR_MSG="Failed to create S3 bucket ${BACKUP_BUCKET} at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
              echo "ERROR: $ERROR_MSG"
              /usr/local/bin/send-rate-limited-email.sh "mongodb-backup" "[ERROR] MongoDB Backup Failed on $(hostname)" "$ERROR_MSG"
              exit 1
            fi
            echo "Bucket created successfully: ${BACKUP_BUCKET}"

            # Harden bucket security
            echo "Applying security hardening to bucket..."

            # Block public access (R2 specific)
            if aws s3api put-public-access-block \
              --bucket "${BACKUP_BUCKET}" \
              --public-access-block-configuration "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true" \
              --endpoint-url="${AWS_ENDPOINT_URL}" 2>/dev/null; then
              echo "✓ Public access blocked"
            else
              echo "⚠ Could not set public access block (may not be supported by R2)"
            fi

            # Set private ACL
            if aws s3api put-bucket-acl \
              --bucket "${BACKUP_BUCKET}" \
              --acl private \
              --endpoint-url="${AWS_ENDPOINT_URL}" 2>/dev/null; then
              echo "✓ Bucket ACL set to private"
            else
              echo "⚠ Could not set bucket ACL (may not be supported by R2)"
            fi

            echo "Bucket security hardening completed"
          else
            echo "Bucket exists: ${BACKUP_BUCKET}"
          fi

          # Perform backup, encrypt with GPG, and stream directly to S3
          echo "Starting mongodump on localhost:${LOGS_PORT}..."
          # if ! mongodump --uri="mongodb://${LOGS_USER}:${LOGS_PASS}@${LOGS_HOST}:${LOGS_PORT}/?tls=true&tlsCAFile=/etc/mongodb/ssl/ca.pem&authSource=admin" --oplog --archive --gzip --quiet | \
          if ! mongodump --uri="mongodb://${LOGS_USER}:${LOGS_PASS}@${LOGS_HOST}:${LOGS_PORT}/${LOGS_NAME}?tls=true&tlsCAFile=/etc/mongodb/ssl/ca.pem&authSource=admin" --archive --gzip --quiet | \
            gpg --symmetric --cipher-algo AES256 --batch --yes --passphrase "$BACKUP_SECRET" | \
            aws s3 cp - "${S3_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}" 2>&1; then
            ERROR_MSG="Failed to backup/encrypt/upload MongoDB at $(date -u +%Y-%m-%dT%H:%M:%SZ). Check MongoDB connection and AWS credentials."
            echo "ERROR: $ERROR_MSG"
            /usr/local/bin/send-rate-limited-email.sh "mongodb-backup" "[ERROR] MongoDB Backup Failed on $(hostname)" "$ERROR_MSG"
            exit 1
          fi

          echo "MongoDB encrypted backup completed: ${S3_PATH}"
          echo "Backup finished at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

    # Create MongoDB backup cleanup script
    - name: Create MongoDB backup cleanup script
      copy:
        dest: /usr/local/bin/cleanup-mongodb-backups.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e
          exec 2>&1  # Redirect stderr to stdout for journal logging

          echo "Starting MongoDB backup cleanup at $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Environment variables
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          AWS_DEFAULT_REGION="${AWS_DEFAULT_REGION:-auto}"
          BACKUP_BUCKET="${LOGS_BACKUP_BUCKET:-forwardemail-backups}"

          # Counters for reporting
          DELETED_OLD=0
          DELETED_DAILY=0
          KEPT_RECENT=0
          ERRORS=0

          # Calculate dates
          THIRTY_DAYS_AGO=$(date -d "30 days ago" +%s)
          TWO_DAYS_AGO=$(date -d "2 days ago" +%s)

          echo "Retention policy: Keep hourly for days 1-2, one per day for days 3-30, delete > 30 days"
          echo "Checking bucket: s3://${BACKUP_BUCKET}/mongo/"

          # List all backups and process
          if ! BACKUP_LIST=$(aws s3 ls s3://${BACKUP_BUCKET}/mongo/ --recursive --endpoint-url="${AWS_ENDPOINT_URL}" 2>&1); then
            ERROR_MSG="Failed to list backups in s3://${BACKUP_BUCKET}/mongo/ at $(date -u +%Y-%m-%dT%H:%M:%SZ). Error: ${BACKUP_LIST}"
            echo "ERROR: $ERROR_MSG"
            /usr/local/bin/send-rate-limited-email.sh "mongo-cleanup" "[ERROR] MongoDB Backup Cleanup Failed on $(hostname)" "$ERROR_MSG"
            exit 1
          fi

          # Process each backup
          echo "$BACKUP_LIST" | while read -r line; do
            # Skip empty lines
            [ -z "$line" ] && continue

            FILE_DATE=$(echo "$line" | awk '{print $1" "$2}')
            FILE_PATH=$(echo "$line" | awk '{print $4}')

            # Extract timestamp from filename (ISO 8601 format: logs-mongo-backup-2025-11-27T19:50:03Z.gz.gpg)
            # Filename format: logs-mongo-backup-YYYY-MM-DDTHH:MM:SSZ.gz.gpg
            FILENAME=$(basename "$FILE_PATH")
            ISO_TIMESTAMP=$(echo "$FILENAME" | grep -oP 'logs-mongo-backup-\K[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z' || echo "")

            # Try to parse timestamp from filename first (more reliable), fallback to S3 metadata date
            if [ -n "$ISO_TIMESTAMP" ]; then
              # Parse ISO 8601 timestamp from filename
              if ! FILE_TIMESTAMP=$(date -d "$ISO_TIMESTAMP" +%s 2>/dev/null); then
                echo "Warning: Could not parse ISO timestamp from filename ${FILENAME}, trying S3 date"
                if ! FILE_TIMESTAMP=$(date -d "$FILE_DATE" +%s 2>/dev/null); then
                  echo "Warning: Could not parse date for ${FILE_PATH}, skipping"
                  ERRORS=$((ERRORS + 1))
                  continue
                fi
              fi
            else
              # Fallback to S3 metadata date
              if ! FILE_TIMESTAMP=$(date -d "$FILE_DATE" +%s 2>/dev/null); then
                echo "Warning: Could not parse date for ${FILE_PATH}, skipping"
                ERRORS=$((ERRORS + 1))
                continue
              fi
            fi

            # Delete backups older than 30 days
            if [ "$FILE_TIMESTAMP" -lt "$THIRTY_DAYS_AGO" ]; then
              echo "Deleting backup older than 30 days: ${FILE_PATH}"
              if aws s3 rm "s3://${BACKUP_BUCKET}/${FILE_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}" 2>&1; then
                DELETED_OLD=$((DELETED_OLD + 1))
              else
                echo "ERROR: Failed to delete ${FILE_PATH}"
                ERRORS=$((ERRORS + 1))
              fi

            # For backups 3-30 days old, keep only one per day
            elif [ "$FILE_TIMESTAMP" -lt "$TWO_DAYS_AGO" ]; then
              # Extract date from ISO 8601 timestamp in filename (YYYY-MM-DD)
              BACKUP_DATE=$(echo "$ISO_TIMESTAMP" | cut -d'T' -f1)

              if [ -z "$BACKUP_DATE" ]; then
                echo "Warning: Could not extract date from timestamp ${ISO_TIMESTAMP}, keeping file"
                KEPT_RECENT=$((KEPT_RECENT + 1))
                continue
              fi

              # Track if we've already kept one backup for this date
              STATE_FILE="/tmp/mongo-cleanup-${BACKUP_DATE}.keep"

              if [ -f "$STATE_FILE" ]; then
                # Already kept one backup for this date, delete this one
                echo "Deleting non-latest daily backup for ${BACKUP_DATE}: ${FILE_PATH}"
                if aws s3 rm "s3://${BACKUP_BUCKET}/${FILE_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}" 2>&1; then
                  DELETED_DAILY=$((DELETED_DAILY + 1))
                else
                  echo "ERROR: Failed to delete ${FILE_PATH}"
                  ERRORS=$((ERRORS + 1))
                fi
              else
                # First backup for this date, keep it and mark as kept
                echo "Keeping daily backup for ${BACKUP_DATE}: ${FILE_PATH}"
                touch "$STATE_FILE"
                KEPT_RECENT=$((KEPT_RECENT + 1))
              fi
            else
              # Recent backup (< 2 days), keep all hourly backups
              KEPT_RECENT=$((KEPT_RECENT + 1))
            fi
          done

          # Summary report
          # Clean up state files
          rm -f /tmp/mongo-cleanup-*.keep

          echo ""
          echo "=== MongoDB Backup Cleanup Summary ==="
          echo "Deleted (>30 days): ${DELETED_OLD}"
          echo "Deleted (daily consolidation): ${DELETED_DAILY}"
          echo "Kept (recent <2 days, hourly): ${KEPT_RECENT}"
          echo "Errors: ${ERRORS}"
          echo "Completed at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Send email alert if there were errors
          if [ "$ERRORS" -gt 0 ]; then
            ERROR_MSG="MongoDB backup cleanup completed with ${ERRORS} errors. Check logs: sudo journalctl -u mongodb-backup.service -n 200"
            echo "WARNING: $ERROR_MSG"
            /usr/local/bin/send-rate-limited-email.sh "mongo-cleanup" "[WARNING] MongoDB Backup Cleanup Had Errors on $(hostname)" "$ERROR_MSG"
          fi

          echo "MongoDB backup cleanup completed successfully"

    # Create systemd service for MongoDB backup
    - name: Create MongoDB backup systemd service
      copy:
        dest: /etc/systemd/system/mongodb-backup.service
        content: |
          # WARNING: This file is managed by Ansible
          # Manual changes will be overwritten on next deployment
          [Unit]
          Description=MongoDB Backup to Cloudflare R2
          OnFailure=failure-notification@%n.service

          [Service]
          Type=oneshot
          RemainAfterExit=no
          TimeoutStartSec=600
          TimeoutStopSec=30
          Environment="AWS_ACCESS_KEY_ID={{ lookup('env', 'AWS_ACCESS_KEY_ID') }}"
          Environment="AWS_SECRET_ACCESS_KEY={{ lookup('env', 'AWS_SECRET_ACCESS_KEY') }}"
          Environment="AWS_ENDPOINT_URL={{ lookup('env', 'AWS_ENDPOINT_URL') }}"
          Environment="AWS_DEFAULT_REGION={{ lookup('env', 'AWS_DEFAULT_REGION') or 'auto' }}"
          Environment="LOGS_BACKUP_BUCKET={{ lookup('env', 'LOGS_BACKUP_BUCKET') | default('forwardemail-backups', true) }}"
          Environment="BACKUP_SECRET={{ lookup('env', 'BACKUP_SECRET') }}"
          Environment="MSMTP_RCPTS={{ lookup('env', 'MSMTP_RCPTS') | default('security@forwardemail.net', true) }}"
          Environment="LOGS_PORT={{ lookup('env', 'LOGS_PORT') | default('27017', true) }}"
          Environment="LOGS_NAME={{ lookup('env', 'LOGS_NAME') }}"
          Environment="LOGS_USER={{ lookup('env', 'LOGS_USER') }}"
          Environment="LOGS_PASS={{ lookup('env', 'LOGS_PASS') }}"
          Environment="LOGS_HOST={{ lookup('env', 'LOGS_HOST') }}"
          ExecStart=/usr/local/bin/backup-mongodb.sh
          ExecStartPost=/usr/local/bin/cleanup-mongodb-backups.sh

    # Create systemd timer for MongoDB backup (hourly)
    - name: Create MongoDB backup systemd timer
      copy:
        dest: /etc/systemd/system/mongodb-backup.timer
        content: |
          # WARNING: This file is managed by Ansible
          # Manual changes will be overwritten on next deployment
          [Unit]
          Description=MongoDB Backup Hourly

          [Timer]
          OnBootSec=15min
          OnUnitActiveSec=1h

          [Install]
          WantedBy=timers.target

    - name: Enable and start MongoDB backup timer
      systemd:
        daemon_reload: true
        name: mongodb-backup.timer
        enabled: true
        state: started

    # ============================================================================
    # POST-DEPLOYMENT SUMMARY
    # ============================================================================
    - name: Display deployment summary
      shell: |
        cat << 'EOF'

        ╔════════════════════════════════════════════════════════════════════════╗
        ║                                                                        ║
        ║                    ✅  MONGODB DEPLOYMENT COMPLETE                     ║
        ║                                                                        ║
        ║  MongoDB has been configured and restarted with:                      ║
        ║    ✅ TLS encryption enabled (requireTLS)                             ║
        ║    ✅ Authentication enabled (admin user created)                     ║
        ║    ✅ Automatic backups configured                                    ║
        ║                                                                        ║
        ║  To verify MongoDB is running:                                        ║
        ║    sudo systemctl status mongod                                       ║
        ║                                                                        ║
        ║  To connect to MongoDB:                                               ║
        ║    /usr/local/bin/mongosh --tls --tlsCAFile /etc/mongodb/ssl/ca.pem \               ║
        ║            --host localhost:27017 \                                   ║
        ║            -u $LOGS_USER -p $LOGS_PASS --authenticationDatabase admin║
        ║                                                                        ║
        ║  To view logs:                                                        ║
        ║    sudo journalctl -u mongod -f                                       ║
        ║                                                                        ║
        ║  Security Status:                                                     ║
        ║    • Only authenticated users can access databases                    ║
        ║    • All connections require TLS encryption                           ║
        ║    • Admin user: $LOGS_USER (from environment)                       ║
        ║                                                                        ║
        ╚════════════════════════════════════════════════════════════════════════╝

        EOF
      changed_when: false
