# Copyright (c) Forward Email LLC
# SPDX-License-Identifier: BUSL-1.1

---
- name: Import security playbook
  import_playbook: security.yml
- name: Import SSH keys playbook
  import_playbook: ssh-keys.yml

- hosts: mongo
  name: Certificate Paths
  vars_prompt:
    - name: input_key
      prompt: "Enter path to certificate private key file on local machine (e.g. /path/to/.ssl-key) [REQUIRED]"
      private: false
    - name: input_cert
      prompt: "Enter path to certificate full chain/certificate file on local machine (e.g. /path/to/.ssl-cert) [REQUIRED]"
      private: false
    - name: input_ca
      prompt: "Enter path to certificate CA bundle file on local machine (e.g. /path/to/.ssl-ca) [REQUIRED]"
      private: false
  tasks:
    - name: Fail if key path is empty
      fail:
        msg: "Certificate private key path is required. Please re-run the playbook and provide a valid path."
      when: (input_key is not defined) or (input_key | length == 0)

    - name: Fail if cert path is empty
      fail:
        msg: "Certificate file path is required. Please re-run the playbook and provide a valid path."
      when: (input_cert is not defined) or (input_cert | length == 0)

    - name: Fail if CA path is empty
      fail:
        msg: "CA bundle file path is required. Please re-run the playbook and provide a valid path."
      when: (input_ca is not defined) or (input_ca | length == 0)

    - name: Check if key file exists locally
      local_action: stat path={{ input_key }}
      become: false
      register: local_key_file

    - name: Fail when local key file does not exist
      fail:
        msg: "key file does not exist: {{ input_key }}"
      when: not local_key_file.stat.exists

    - name: Check if cert file exists locally
      local_action: stat path={{ input_cert }}
      become: false
      register: local_cert_file

    - name: Fail when local cert file does not exist
      fail:
        msg: "cert file does not exist: {{ input_cert }}"
      when: not local_cert_file.stat.exists

    - name: Check if CA file exists locally
      local_action: stat path={{ input_ca }}
      become: false
      register: local_ca_file

    - name: Fail when local CA file does not exist
      fail:
        msg: "CA file does not exist: {{ input_ca }}"
      when: not local_ca_file.stat.exists

    - name: Store certificate paths as facts
      set_fact:
        ssl_key_path: "{{ input_key }}"
        ssl_cert_path: "{{ input_cert }}"
        ssl_ca_path: "{{ input_ca }}"

- hosts: mongo
  name: Hostname
  become: true
  become_user: root
  tasks:
    - name: Validate required environment variables
      assert:
        that:
          - lookup('env', 'MONGO_HOST') != ''
          - lookup('env', 'MONGO_PORT') != ''
          - lookup('env', 'AWS_ACCESS_KEY_ID') != ''
          - lookup('env', 'AWS_SECRET_ACCESS_KEY') != ''
          - lookup('env', 'AWS_ENDPOINT_URL') != ''
          - lookup('env', 'BACKUP_SECRET') != ''
        fail_msg: |
          Required environment variables are missing for MongoDB playbook.
          Please ensure the following variables are set in your .env file:
          - MONGO_HOST
          - MONGO_PORT
          - SSL_CERT_PATH
          - SSL_KEY_PATH
          - SSL_CA_PATH
          - AWS_ACCESS_KEY_ID
          - AWS_SECRET_ACCESS_KEY
          - AWS_ENDPOINT_URL
          - BACKUP_SECRET
        quiet: false

    - name: Set hostname
      hostname:
        name: "{{ lookup('env', 'MONGO_HOST') }}"

- hosts: mongo
  name: MongoDB
  become: true
  become_user: root
  handlers:
    - name: Reload UFW
      ufw:
        state: reloaded
    - name: Restart MongoDB
      service:
        name: mongod
        state: restarted
  tasks:
    # MongoDB-specific sysctl optimizations
    # Note: THP, ulimits, and base sysctl settings are inherited from security.yml
    - name: Configure MongoDB-specific sysctl parameters
      ansible.builtin.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-mongodb.conf
      loop:
        - { name: 'vm.dirty_background_ratio', value: '10' }
        - { name: 'vm.dirty_ratio', value: '20' }
        - { name: 'net.core.somaxconn', value: '4096' }
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '4096' }
        - { name: 'net.ipv4.tcp_fin_timeout', value: '30' }
        - { name: 'net.ipv4.tcp_keepalive_intvl', value: '30' }
        - { name: 'net.ipv4.tcp_keepalive_time', value: '120' }

    # Configure swap for MongoDB stability
    # MongoDB requires swap to prevent OOM crashes during high memory usage
    # Best practice: swap file size = total system RAM
    - name: Get total system memory in MB
      shell: free -m | awk '/^Mem:/{print $2}'
      register: total_memory_mb
      changed_when: false

    - name: Check if swap file exists
      stat:
        path: /swapfile
      register: swapfile_stat

    - name: Check current swap size
      shell: swapon --show=SIZE --noheadings --bytes | head -1
      register: current_swap_bytes
      changed_when: false
      failed_when: false

    - name: Calculate required swap size in bytes
      set_fact:
        required_swap_mb: "{{ total_memory_mb.stdout | int }}"
        required_swap_bytes: "{{ (total_memory_mb.stdout | int) * 1024 * 1024 }}"

    - name: Disable existing swap if size doesn't match
      command: swapoff /swapfile
      when:
        - swapfile_stat.stat.exists
        - current_swap_bytes.stdout != ""
        - current_swap_bytes.stdout | int != required_swap_bytes | int
      ignore_errors: true

    - name: Remove old swap file if size doesn't match
      file:
        path: /swapfile
        state: absent
      when:
        - swapfile_stat.stat.exists
        - current_swap_bytes.stdout != ""
        - current_swap_bytes.stdout | int != required_swap_bytes | int

    - name: Create swap file with size equal to RAM
      command: fallocate -l {{ required_swap_mb }}M /swapfile
      args:
        creates: /swapfile

    - name: Set swap file permissions
      file:
        path: /swapfile
        mode: '0600'
        owner: root
        group: root

    - name: Format swap file
      command: mkswap /swapfile
      when: not swapfile_stat.stat.exists or (current_swap_bytes.stdout | int != required_swap_bytes | int)
      register: mkswap_result
      changed_when: "'Setting up swapspace' in mkswap_result.stdout"

    - name: Enable swap file
      command: swapon /swapfile
      when: mkswap_result is changed

    - name: Add swap to /etc/fstab
      lineinfile:
        path: /etc/fstab
        line: '/swapfile none swap sw 0 0'
        state: present
        regexp: '^/swapfile'

    - name: Set swappiness for MongoDB (minimize swapping but allow it for safety)
      ansible.builtin.sysctl:
        name: vm.swappiness
        value: '1'
        state: present
        reload: true
        sysctl_file: /etc/sysctl.d/99-mongodb.conf

    # Install MongoDB using trfore.mongodb_install role
    - name: Install MongoDB v6
      include_role:
        name: trfore.mongodb_install
      vars:
        mongodb_version: "6.0.18"
        mongodb_security_authorization: "enabled"

    # Configure MongoDB for TLS/SSL
    - name: Ensure MongoDB TLS/SSL configuration directory exists
      file:
        path: /etc/mongodb/ssl
        state: directory
        owner: mongodb
        group: mongodb
        mode: "0750"

    # Copy SSL certificates directly from local machine to MongoDB directory
    - name: Copy SSL certificate to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_cert_path'] }}"
        dest: /etc/mongodb/ssl/mongodb.crt
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Copy SSL private key to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_key_path'] }}"
        dest: /etc/mongodb/ssl/mongodb.key
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Copy CA certificate to MongoDB directory
      copy:
        src: "{{ hostvars[inventory_hostname]['ssl_ca_path'] }}"
        dest: /etc/mongodb/ssl/ca.pem
        owner: mongodb
        group: mongodb
        mode: "0400"

    - name: Create MongoDB TLS/SSL certificate PEM file (cert + key)
      shell: |
        cat /etc/mongodb/ssl/mongodb.crt /etc/mongodb/ssl/mongodb.key > /etc/mongodb/ssl/mongodb.pem
        chown mongodb:mongodb /etc/mongodb/ssl/mongodb.pem
        chmod 0400 /etc/mongodb/ssl/mongodb.pem
      args:
        creates: /etc/mongodb/ssl/mongodb.pem

    - name: Configure MongoDB TLS/SSL in mongod.conf
      blockinfile:
        path: /etc/mongod.conf
        marker: "# {mark} ANSIBLE MANAGED BLOCK - TLS/SSL"
        block: |
          net:
            tls:
              mode: requireTLS
              certificateKeyFile: /etc/mongodb/ssl/mongodb.pem
              CAFile: /etc/mongodb/ssl/ca.pem
      notify: Restart MongoDB

    # UFW Configuration
    - name: Enable ufw
      ufw:
        state: enabled
        policy: deny
        direction: incoming

    - name: Limit ufw ssh
      ufw:
        rule: limit
        port: 22
        proto: tcp

    - name: Allow ssh
      ufw:
        rule: allow
        port: 22
        proto: tcp

    # Fetch IP whitelist and configure UFW
    - name: Fetch IP whitelist from forwardemail.net
      uri:
        url: https://forwardemail.net/ips/v4.txt?comments=false
        return_content: true
      register: ip_whitelist_response

    - name: Parse IP whitelist
      set_fact:
        allowed_ips: "{{ ip_whitelist_response.content.split('\n') | select('match', '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$') | list }}"

    - name: Allow MongoDB port from whitelisted IPs
      ufw:
        rule: allow
        from_ip: "{{ item }}"
        to_port: "{{ lookup('env', 'MONGO_PORT') }}"
        proto: tcp
        comment: "Auto-whitelist MongoDB"
      loop: "{{ allowed_ips }}"
      notify: Reload UFW

    # Install UFW whitelist update script
    - name: Create UFW whitelist update script
      copy:
        dest: /usr/local/bin/update-mongo-ufw-whitelist.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Fetch current IP list
          NEW_IPS=$(curl -s https://forwardemail.net/ips/v4.txt?comments=false | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$')

          # Get current UFW rules for MongoDB port
          MONGO_PORT="${MONGO_PORT:-27017}"
          CURRENT_IPS=$(ufw status | grep "${MONGO_PORT}/tcp" | grep "ALLOW" | awk '{print $3}' | sort -u)

          # Track if changes were made
          CHANGED=0

          # Add new IPs
          for ip in $NEW_IPS; do
            if ! echo "$CURRENT_IPS" | grep -q "^${ip}$"; then
              ufw allow from "$ip" to any port "$MONGO_PORT" proto tcp comment "Auto-whitelist MongoDB"
              CHANGED=1
            fi
          done

          # Remove old IPs (not in new list)
          for ip in $CURRENT_IPS; do
            if ! echo "$NEW_IPS" | grep -q "^${ip}$"; then
              # Find and delete the rule
              RULE_NUM=$(ufw status numbered | grep "${MONGO_PORT}/tcp" | grep "$ip" | grep -oP '^\[\s*\K[0-9]+' | head -1)
              if [ -n "$RULE_NUM" ]; then
                echo "y" | ufw delete "$RULE_NUM"
                CHANGED=1
              fi
            fi
          done

          # Reload UFW if changes were made
          if [ $CHANGED -eq 1 ]; then
            ufw reload
          fi

    # Create systemd timer for UFW whitelist updates
    - name: Create UFW whitelist update systemd service
      copy:
        dest: /etc/systemd/system/mongo-ufw-whitelist-update.service
        content: |
          [Unit]
          Description=Update MongoDB UFW IP Whitelist

          [Service]
          Type=oneshot
          ExecStart=/usr/local/bin/update-mongo-ufw-whitelist.sh

    - name: Create UFW whitelist update systemd timer
      copy:
        dest: /etc/systemd/system/mongo-ufw-whitelist-update.timer
        content: |
          [Unit]
          Description=Update MongoDB UFW IP Whitelist Every 10 Minutes

          [Timer]
          OnBootSec=5min
          OnUnitActiveSec=10min

          [Install]
          WantedBy=timers.target

    - name: Enable and start UFW whitelist update timer
      systemd:
        daemon_reload: true
        name: mongo-ufw-whitelist-update.timer
        enabled: true
        state: started

       # Install AWS CLI and GPG dependencies
    - name: Install AWS CLI and GPG dependencies
      apt:
        name:
          - python3-pip
          - unzip
          - gnupg
        update_cache: true

    - name: Install AWS CLI
      shell: |
        if ! command -v aws &> /dev/null; then
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "/tmp/awscliv2.zip"
          unzip -q /tmp/awscliv2.zip -d /tmp
          /tmp/aws/install
          rm -rf /tmp/aws /tmp/awscliv2.zip
        fi
      args:
        creates: /usr/local/bin/aws

    # Create MongoDB backup script
    - name: Create MongoDB backup script
      copy:
        dest: /usr/local/bin/backup-mongodb.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables (set via systemd service or environment)
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${MONGO_BACKUP_BUCKET:-forwardemail-backups}"
          BACKUP_SECRET="${BACKUP_SECRET}"

          # Check if BACKUP_SECRET is set
          if [ -z "$BACKUP_SECRET" ]; then
            echo "Error: BACKUP_SECRET environment variable is not set"
            exit 1
          fi

          # Timestamp and path
          TIMESTAMP=$(date +%Y/%m/%d/%H)
          BACKUP_NAME="mongodb-backup-$(date +%Y%m%d-%H%M%S).archive.gz.gpg"
          S3_PATH="s3://${BACKUP_BUCKET}/mongodb/${TIMESTAMP}/${BACKUP_NAME}"

          # Perform backup, encrypt with GPG, and stream directly to S3
          mongodump --host=localhost --port="${MONGO_PORT:-27017}" --oplog --archive --gzip | \
            gpg --symmetric --cipher-algo AES256 --batch --yes --passphrase "$BACKUP_SECRET" | \
            aws s3 cp - "${S3_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"

          echo "MongoDB encrypted backup completed: ${S3_PATH}"

    # Create MongoDB backup cleanup script
    - name: Create MongoDB backup cleanup script
      copy:
        dest: /usr/local/bin/cleanup-mongodb-backups.sh
        mode: "0755"
        content: |
          #!/bin/bash
          set -e

          # Environment variables
          AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
          AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
          AWS_ENDPOINT_URL="${AWS_ENDPOINT_URL}"
          BACKUP_BUCKET="${MONGO_BACKUP_BUCKET:-forwardemail-backups}"

          # Calculate dates
          THIRTY_DAYS_AGO=$(date -d "30 days ago" +%s)
          SEVEN_DAYS_AGO=$(date -d "7 days ago" +%s)

          # List all backups
          aws s3 ls "s3://${BACKUP_BUCKET}/mongodb/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | while read -r line; do
            FILE_DATE=$(echo "$line" | awk '{print $1}')
            FILE_PATH=$(echo "$line" | awk '{print $4}')
            FILE_TIMESTAMP=$(date -d "$FILE_DATE" +%s)

            # Delete backups older than 30 days
            if [ "$FILE_TIMESTAMP" -lt "$THIRTY_DAYS_AGO" ]; then
              aws s3 rm "s3://${BACKUP_BUCKET}/${FILE_PATH}" --endpoint-url="${AWS_ENDPOINT_URL}"
              echo "Deleted old backup: ${FILE_PATH}"
            # For backups 8-30 days old, keep only one per day (delete others)
            elif [ "$FILE_TIMESTAMP" -lt "$SEVEN_DAYS_AGO" ]; then
              # Extract date from path (YYYY/MM/DD)
              BACKUP_DATE=$(echo "$FILE_PATH" | grep -oP 'mongodb/\K[0-9]{4}/[0-9]{2}/[0-9]{2}')

              # Get all backups for this date
              DAILY_BACKUPS=$(aws s3 ls "s3://${BACKUP_BUCKET}/mongodb/${BACKUP_DATE}/" --recursive --endpoint-url="${AWS_ENDPOINT_URL}" | awk '{print $4}' | sort)

              # Keep only the latest backup for the day
              LATEST_BACKUP=$(echo "$DAILY_BACKUPS" | tail -1)

              # Delete all except the latest
              for backup in $DAILY_BACKUPS; do
                if [ "$backup" != "$LATEST_BACKUP" ]; then
                  aws s3 rm "s3://${BACKUP_BUCKET}/${backup}" --endpoint-url="${AWS_ENDPOINT_URL}"
                  echo "Deleted non-latest daily backup: ${backup}"
                fi
              done
            fi
          done

          echo "MongoDB backup cleanup completed"

    # Create systemd service for MongoDB backup
    - name: Create MongoDB backup systemd service
      copy:
        dest: /etc/systemd/system/mongodb-backup.service
        content: |
          [Unit]
          Description=MongoDB Backup to Cloudflare R2

          [Service]
          Type=oneshot
          Environment="AWS_ACCESS_KEY_ID={{ lookup('env', 'AWS_ACCESS_KEY_ID') }}"
          Environment="AWS_SECRET_ACCESS_KEY={{ lookup('env', 'AWS_SECRET_ACCESS_KEY') }}"
          Environment="AWS_ENDPOINT_URL={{ lookup('env', 'AWS_ENDPOINT_URL') }}"
          Environment="MONGO_BACKUP_BUCKET={{ lookup('env', 'MONGO_BACKUP_BUCKET') | default('forwardemail-backups', true) }}"
          Environment="BACKUP_SECRET={{ lookup('env', 'BACKUP_SECRET') }}"
          ExecStart=/usr/local/bin/backup-mongodb.sh
          ExecStartPost=/usr/local/bin/cleanup-mongodb-backups.sh

    # Create systemd timer for MongoDB backup (every 6 hours)
    - name: Create MongoDB backup systemd timer
      copy:
        dest: /etc/systemd/system/mongodb-backup.timer
        content: |
          [Unit]
          Description=MongoDB Backup Every 6 Hours

          [Timer]
          OnBootSec=15min
          OnUnitActiveSec=6h

          [Install]
          WantedBy=timers.target

    - name: Enable and start MongoDB backup timer
      systemd:
        daemon_reload: true
        name: mongodb-backup.timer
        enabled: true
        state: started