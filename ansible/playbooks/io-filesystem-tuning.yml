---
# I/O and Filesystem Tuning Playbook
# Optimizes I/O scheduler and filesystem settings for database workloads

- name: "I/O and Filesystem Tuning for {{ service_name }}"
  hosts: all
  become: true
  tasks:
    - name: "Check if {{ data_directory }} exists"
      stat:
        path: "{{ data_directory }}"
      register: data_dir_check

    - name: "Skip I/O tuning if {{ data_directory }} does not exist"
      debug:
        msg: "Skipping I/O tuning - {{ data_directory }} does not exist yet"
      when: not data_dir_check.stat.exists

    # Copy device detection script
    # Remove old script to force update
    - name: Remove old device detection script
      file:
        path: /usr/local/bin/detect-block-device.sh
        state: absent
      when: data_dir_check.stat.exists

    - name: Copy device detection script
      copy:
        src: files/detect-block-device.sh
        dest: /usr/local/bin/detect-block-device.sh
        mode: '0755'
        owner: root
        group: root
      when: data_dir_check.stat.exists

    # Detect block device for data directory
    - name: "Get block device for {{ data_directory }}"
      command: /usr/local/bin/detect-block-device.sh "{{ data_directory }}"
      register: block_device_result
      changed_when: false
      failed_when: block_device_result.rc != 0
      when: data_dir_check.stat.exists

    - name: Validate device name is not empty
      fail:
        msg: "Device detection returned empty string for {{ data_directory }}"
      when: data_dir_check.stat.exists and block_device_result.stdout | trim == ''

    - name: Debug device detection result
      debug:
        msg: |
          Device detection for {{ data_directory }}:
          Raw output: '{{ block_device_result.stdout }}'
          Trimmed: '{{ block_device_result.stdout | trim }}'
          Will use: /dev/{{ block_device_result.stdout | trim }}
      when: data_dir_check.stat.exists

    - name: Set block device facts
      set_fact:
        device_name: "{{ block_device_result.stdout | trim }}"
        block_device: "/dev/{{ block_device_result.stdout | trim }}"
      when: data_dir_check.stat.exists

    - name: Verify block device exists and is a block device
      stat:
        path: "{{ block_device }}"
      register: block_device_check
      when: data_dir_check.stat.exists

    - name: Fail if block device is invalid
      fail:
        msg: |
          Block device '{{ block_device }}' does not exist or is not a block device.
          Device detection may have failed. Check the debug output above.
      when: data_dir_check.stat.exists and (not block_device_check.stat.exists or not block_device_check.stat.isblk)

    # Detect if device is multi-queue (NVMe, modern SSD)
    - name: Check if device is multi-queue
      stat:
        path: "/sys/block/{{ device_name }}/mq"
      register: mq_check
      when: data_dir_check.stat.exists

    # Set I/O scheduler variable based on device type
    - name: Set I/O scheduler based on device type
      set_fact:
        io_scheduler: "{{ 'none' if mq_check.stat.exists else 'deadline' }}"
      when: data_dir_check.stat.exists

    # Set I/O scheduler based on device type
    - name: Set I/O scheduler for device
      shell: |
        echo "{{ io_scheduler }}" > /sys/block/{{ device_name }}/queue/scheduler
      register: scheduler_result
      changed_when: scheduler_result.rc == 0
      failed_when: false
      when: data_dir_check.stat.exists

    - name: "Make I/O scheduler persistent via udev rule"
      copy:
        dest: "/etc/udev/rules.d/60-{{ service_identifier }}-scheduler.rules"
        content: |
          # Set I/O scheduler for {{ service_name }} data device
          ACTION=="add|change", KERNEL=="{{ device_name }}", ATTR{queue/scheduler}="{{ io_scheduler }}"
        mode: "0644"
      when: data_dir_check.stat.exists

    # Set read-ahead for database workloads
    - name: Set read-ahead for device
      shell: |
        blockdev --setra {{ read_ahead_kb * 2 }} {{ block_device }}
      register: readahead_result
      changed_when: readahead_result.rc == 0
      when: data_dir_check.stat.exists

    - name: "Make read-ahead persistent via udev rule"
      copy:
        dest: "/etc/udev/rules.d/60-{{ service_identifier }}-readahead.rules"
        content: |
          # Set read-ahead for {{ service_name }} data device
          ACTION=="add|change", KERNEL=="{{ device_name }}", ATTR{bdi/read_ahead_kb}="{{ read_ahead_kb }}"
        mode: "0644"
      when: data_dir_check.stat.exists

    # Check filesystem mount options
    - name: "Get current mount options for {{ data_directory }}"
      shell: |
        mount | grep "{{ block_device }}" | awk '{print $6}' | tr -d '()'
      register: mount_options_result
      changed_when: false
      when: data_dir_check.stat.exists

    - name: "Check filesystem mount options"
      set_fact:
        has_noatime: "{{ 'noatime' in mount_options_result.stdout or 'relatime' in mount_options_result.stdout }}"
        has_nodiratime: "{{ 'nodiratime' in mount_options_result.stdout }}"
        has_discard: "{{ 'discard' in mount_options_result.stdout }}"
      when: data_dir_check.stat.exists

    - name: "Display filesystem mount options recommendation"
      debug:
        msg: |
          â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
          â•‘                                                                        â•‘
          â•‘  ğŸ“ Filesystem Mount Options for {{ data_directory }}                 â•‘
          â•‘                                                                        â•‘
          â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
          {% if not has_noatime or not has_nodiratime %}â•‘                                                                        â•‘
          â•‘  âš ï¸  RECOMMENDED: Add these mount options to /etc/fstab:              â•‘
          â•‘                                                                        â•‘{% if not has_noatime %}
          â•‘  â€¢ noatime    - Disable access time updates (improves performance)    â•‘{% endif %}{% if not has_nodiratime %}
          â•‘  â€¢ nodiratime - Disable directory access time updates                 â•‘{% endif %}{% if not has_discard %}
          â•‘  â€¢ discard    - Enable TRIM for SSDs (if using SSD)                   â•‘{% endif %}
          â•‘                                                                        â•‘
          â•‘  Example fstab entry:                                                  â•‘
          â•‘  {{ block_device }} {{ data_directory }} ext4 defaults,noatime,nodiratime{% if not has_discard %},discard{% endif %} 0 2
          â•‘                                                                        â•‘
          â•‘  Then remount: sudo mount -o remount {{ data_directory }}
          â•‘                                                                        â•‘{% else %}All recommended mount options are enabled!                           â•‘{% endif %}
          â•‘                                                                        â•‘
          â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      when: data_dir_check.stat.exists

    # Reload udev rules
    - name: Reload udev rules
      command: udevadm control --reload-rules
      when: data_dir_check.stat.exists
      changed_when: false

    - name: Trigger udev rules
      command: udevadm trigger
      when: data_dir_check.stat.exists
      changed_when: false
